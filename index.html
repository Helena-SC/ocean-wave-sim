<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Ocean Wave Simulation</title>

  <style>
    :root{
      --panel-bg: rgba(12, 18, 28, 0.62);
      --panel-border: rgba(255,255,255,0.14);
      --text: rgba(235, 245, 255, 0.92);
      --muted: rgba(235, 245, 255, 0.70);
      --shadow: 0 18px 55px rgba(0,0,0,0.40);
      --radius: 18px;

      /* 用于匹配背景图的“地平线高度”（0~1，越大地平线越靠下） */
      --horizon: 0.53;
    }

    html, body {
      height:100%;
      margin:0;
      overflow:hidden;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      background: #050F1E;
    }

    /* 背景：你的星空照片（只作为背景层） */
    body{
      background-image: url("./huan-xiang-shi-xing-xi-bei-jing.jpg");
      background-size: cover;
      background-position: center top;
      background-repeat: no-repeat;
      background-attachment: fixed;
    }

    /* 用一层“遮罩”把原图里水面那部分压暗，避免和我们渲染的海面叠加看起来脏 */
    .bg-mask{
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 1;
      background:
        linear-gradient(
          to bottom,
          rgba(0,0,0,0.00) 0%,
          rgba(0,0,0,0.00) calc(var(--horizon) * 100%),
          rgba(5,15,30,0.88) calc(var(--horizon) * 100% + 2%),
          rgba(5,15,30,1.00) 100%
        );
    }

    #app{
      position: fixed;
      inset: 0;
      z-index: 2;
    }
    canvas{
      display:block;
      width:100%;
      height:100%;
    }

    /* 轻微电影感：暗角 */
    .fx {
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 8;
      background:
        radial-gradient(circle at 62% 36%, rgba(255,255,255,0.08) 0%, rgba(255,255,255,0.03) 18%, rgba(0,0,0,0.00) 44%),
        radial-gradient(circle at 50% 50%, rgba(0,0,0,0.00) 34%, rgba(0,0,0,0.60) 78%, rgba(0,0,0,0.92) 100%);
      mix-blend-mode: multiply;
    }

    /* 颗粒噪声 */
    #grain {
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 9;
      opacity: 0.055;
      mix-blend-mode: overlay;
    }

    /* HUD */
    .hud {
      position: fixed;
      left: 18px;
      top: 18px;
      width: min(380px, calc(100vw - 36px));
      padding: 16px 16px 14px;
      border-radius: var(--radius);
      background: var(--panel-bg);
      border: 1px solid var(--panel-border);
      box-shadow: var(--shadow);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      color: var(--text);
      user-select: none;
      z-index: 10;
    }
    .title { display:flex; align-items:center; justify-content:space-between; gap: 10px; margin-bottom: 8px; }
    .title h1 { font-size: 15px; letter-spacing: 0.2px; margin:0; font-weight: 650; }
    .badges { display:flex; gap: 8px; align-items:center; }
    .badge {
      font-size: 11px; color: rgba(235,245,255,0.75);
      padding: 4px 10px; border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.04);
    }
    .badge.live{
      border-color: rgba(120, 255, 220, 0.22);
      background: rgba(120, 255, 220, 0.08);
      color: rgba(210, 255, 242, 0.92);
    }
    .desc {
      font-size: 11px;
      color: rgba(235,245,255,0.70);
      line-height: 1.35;
      margin-bottom: 10px;
    }

    .row { display:flex; gap: 12px; align-items:center; margin: 10px 0; }
    .row label { flex: 0 0 92px; font-size: 12px; color: var(--muted); }
    .row input[type="range"] { flex: 1; accent-color: rgb(120, 210, 255); }
    .val { flex: 0 0 58px; text-align:right; font-variant-numeric: tabular-nums; font-size: 12px; color: var(--text); }

    .buttons { display:flex; gap: 10px; margin-top: 12px; }
    button {
      flex: 1;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06);
      color: var(--text);
      padding: 9px 12px;
      font-size: 12px;
      cursor: pointer;
      transition: transform 120ms ease, background 120ms ease;
    }
    button:hover { background: rgba(255,255,255,0.10); transform: translateY(-1px); }
    button:active { transform: translateY(0px); }

    .hint {
      margin-top: 10px;
      font-size: 11px;
      color: rgba(235,245,255,0.62);
      line-height: 1.35;
    }
    .hint kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 7px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.05);
      color: rgba(235,245,255,0.90);
    }

    /* Error overlay */
    .overlay {
      position: fixed; inset: 0;
      display: none; align-items: center; justify-content: center;
      padding: 22px;
      background: rgba(5, 15, 30, 0.94);
      color: rgba(235, 245, 255, 0.92);
      z-index: 60;
    }
    .overlay .card {
      width: min(860px, 100%);
      border: 1px solid rgba(255,255,255,0.14);
      border-radius: 16px;
      background: rgba(18, 28, 40, 0.55);
      box-shadow: 0 18px 55px rgba(0,0,0,0.35);
      padding: 16px;
    }
    .overlay h2 { margin: 0 0 10px 0; font-size: 14px; }
    .overlay pre {
      margin: 0;
      white-space: pre-wrap;
      word-break: break-word;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 12px;
      color: rgba(235, 245, 255, 0.84);
      line-height: 1.35;
    }
  </style>
</head>

<body>
  <div class="bg-mask"></div>
  <div id="app"></div>
  <div class="fx"></div>
  <canvas id="grain"></canvas>

  <div class="hud" aria-label="Ocean Wave Simulation Controls">
    <div class="title">
      <h1>Ocean Wave Simulation</h1>
      <div class="badges">
        <div class="badge live">Live</div>
      </div>
    </div>

    <div class="desc">
      Background is your photo. Ocean is simulated with layered waves + env reflection sampled from that photo.
    </div>

    <div class="row">
      <label for="wind">Wind speed</label>
      <input id="wind" type="range" min="0" max="30" step="0.1" value="12" />
      <div class="val" id="windVal">1.20×</div>
    </div>

    <div class="row">
      <label for="height">Wave height</label>
      <input id="height" type="range" min="0" max="3" step="0.01" value="1.0" />
      <div class="val" id="heightVal">1.00×</div>
    </div>

    <div class="row">
      <label for="light">Lighting</label>
      <input id="light" type="range" min="0" max="1" step="0.001" value="0.62" />
      <div class="val" id="lightVal">62%</div>
    </div>

    <div class="buttons">
      <button id="resetBtn" type="button">Reset</button>
      <button id="pauseBtn" type="button">Pause</button>
      <button id="fsBtn" type="button">Fullscreen</button>
    </div>

    <div class="hint">
      Drag to look around. Scroll to zoom. Press <kbd>F</kbd> fullscreen, <kbd>Space</kbd> pause.
    </div>
  </div>

  <div class="overlay" id="overlay">
    <div class="card">
      <h2>Ocean Wave Simulation error</h2>
      <pre id="overlayText"></pre>
    </div>
  </div>

  <script type="module">
    import * as THREE from "./vendor/three.module.min.js";

    const overlay = document.getElementById("overlay");
    const overlayText = document.getElementById("overlayText");

    function showError(err){
      const msg = (err && err.stack) ? err.stack : String(err);
      console.error(msg);
      overlayText.textContent = msg;
      overlay.style.display = "flex";
    }

    // --- Grain ---
    const grain = document.getElementById("grain");
    const gctx = grain.getContext("2d", { alpha: true });
    function resizeGrain(){
      grain.width = Math.floor(window.innerWidth);
      grain.height = Math.floor(window.innerHeight);
    }
    resizeGrain();
    function drawGrain(){
      const w = grain.width, h = grain.height;
      const img = gctx.createImageData(w, h);
      const d = img.data;
      for (let i = 0; i < d.length; i += 16){
        const v = (Math.random() * 255) | 0;
        d[i+0] = v; d[i+1] = v; d[i+2] = v; d[i+3] = 255;
      }
      gctx.putImageData(img, 0, 0);
    }

    try{
      // ---------- UI ----------
      const ui = {
        wind: document.getElementById("wind"),
        height: document.getElementById("height"),
        light: document.getElementById("light"),
        windVal: document.getElementById("windVal"),
        heightVal: document.getElementById("heightVal"),
        lightVal: document.getElementById("lightVal"),
        resetBtn: document.getElementById("resetBtn"),
        pauseBtn: document.getElementById("pauseBtn"),
        fsBtn: document.getElementById("fsBtn"),
      };
      function syncLabels(){
        ui.windVal.textContent = (Number(ui.wind.value) / 10).toFixed(2) + "×";
        ui.heightVal.textContent = Number(ui.height.value).toFixed(2) + "×";
        ui.lightVal.textContent = Math.round(Number(ui.light.value) * 100) + "%";
      }
      ["input","change"].forEach(evt => {
        ui.wind.addEventListener(evt, syncLabels);
        ui.height.addEventListener(evt, syncLabels);
        ui.light.addEventListener(evt, syncLabels);
      });
      syncLabels();

      // ---------- Renderer (透明，让背景照片透出来) ----------
      const app = document.getElementById("app");
      const isMobile = /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
      const dpr = Math.min(window.devicePixelRatio || 1, isMobile ? 1.25 : 2.0);

      const renderer = new THREE.WebGLRenderer({
        antialias: !isMobile,
        powerPreference: "high-performance",
        alpha: true
      });
      renderer.setPixelRatio(dpr);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1.0;
      renderer.setClearColor(0x000000, 0.0);
      app.appendChild(renderer.domElement);

      const scene = new THREE.Scene();

      // ---------- Camera / minimal orbit ----------
      const camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.05, 5000);

      const orbit = {
        target: new THREE.Vector3(0, 0.55, 30.0),
        radius: 28,
        yaw: 0.0,
        pitch: 0.14,
        minRadius: 12,
        maxRadius: 110,
        minPitch: 0.06,
        maxPitch: Math.PI * 0.40,
        dragging: false,
        lastX: 0,
        lastY: 0,
        speed: 0.0070
      };

      function updateCamera(){
        const cp = Math.cos(orbit.pitch), sp = Math.sin(orbit.pitch);
        const cy = Math.cos(orbit.yaw),   sy = Math.sin(orbit.yaw);

        const x = orbit.radius * cp * cy;
        const z = orbit.radius * cp * sy;
        const y = orbit.radius * sp;

        // 向前看：让海平线更接近你图片的山脉位置
        camera.position.set(
          orbit.target.x + x,
          orbit.target.y + y,
          orbit.target.z - 26.0 - z
        );
        camera.lookAt(orbit.target);
      }
      updateCamera();

      renderer.domElement.style.touchAction = "none";
      renderer.domElement.addEventListener("pointerdown", (e) => {
        orbit.dragging = true;
        orbit.lastX = e.clientX; orbit.lastY = e.clientY;
        renderer.domElement.setPointerCapture(e.pointerId);
      });
      renderer.domElement.addEventListener("pointermove", (e) => {
        if (!orbit.dragging) return;
        const dx = e.clientX - orbit.lastX;
        const dy = e.clientY - orbit.lastY;
        orbit.lastX = e.clientX; orbit.lastY = e.clientY;

        orbit.yaw   -= dx * orbit.speed;
        orbit.pitch -= dy * orbit.speed;
        orbit.pitch = Math.max(orbit.minPitch, Math.min(orbit.maxPitch, orbit.pitch));
        updateCamera();
      });
      renderer.domElement.addEventListener("pointerup", (e) => {
        orbit.dragging = false;
        try{ renderer.domElement.releasePointerCapture(e.pointerId); }catch(_){}
      });
      renderer.domElement.addEventListener("wheel", (e) => {
        e.preventDefault();
        const s = (e.deltaY > 0) ? 1.06 : 0.94;
        orbit.radius = Math.max(orbit.minRadius, Math.min(orbit.maxRadius, orbit.radius * s));
        updateCamera();
      }, { passive: false });

      // ---------- A soft key light (只作为高光来源，不做月亮物体) ----------
      const ambient = new THREE.AmbientLight(0x9db6d6, 0.06);
      scene.add(ambient);

      const key = new THREE.DirectionalLight(0xe9f3ff, 1.10);
      key.position.set(40, 65, 10);
      scene.add(key);

      // ---------- Env texture: 用同一张照片做海面反射（关键：真实感） ----------
      const envTex = await new Promise((resolve, reject) => {
        const loader = new THREE.TextureLoader();
        loader.load(
          "./huan-xiang-shi-xing-xi-bei-jing.jpg",
          (tex) => {
            tex.colorSpace = THREE.SRGBColorSpace;
            tex.wrapS = THREE.ClampToEdgeWrapping;
            tex.wrapT = THREE.ClampToEdgeWrapping;
            tex.minFilter = THREE.LinearMipmapLinearFilter;
            tex.magFilter = THREE.LinearFilter;
            tex.generateMipmaps = true;
            resolve(tex);
          },
          undefined,
          (err) => reject(err)
        );
      });

      // ---------- Ocean mesh ----------
      const oceanSize = 1800
