<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Ocean Wave Simulation</title>
  <style>
    :root{
      --panel-bg: rgba(18, 28, 40, 0.55);
      --panel-border: rgba(255,255,255,0.14);
      --text: rgba(235, 245, 255, 0.92);
      --muted: rgba(235, 245, 255, 0.70);
      --shadow: 0 18px 55px rgba(0,0,0,0.35);
      --radius: 18px;
    }
    html, body { height: 100%; margin: 0; background: #07111d; overflow: hidden; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; }
    #app { position: fixed; inset: 0; }
    canvas { display:block; width:100%; height:100%; }

    .hud {
      position: fixed; left: 18px; top: 18px;
      width: min(360px, calc(100vw - 36px));
      padding: 16px 16px 14px;
      border-radius: var(--radius);
      background: var(--panel-bg);
      border: 1px solid var(--panel-border);
      box-shadow: var(--shadow);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      color: var(--text);
      user-select: none;
      z-index: 10;
    }
    .title { display:flex; align-items:baseline; justify-content:space-between; gap: 10px; margin-bottom: 12px; }
    .title h1 { font-size: 16px; letter-spacing: 0.2px; margin:0; font-weight: 650; }
    .badge { font-size: 12px; color: var(--muted); padding: 4px 10px; border-radius: 999px; border: 1px solid var(--panel-border); }
    .row { display:flex; gap: 12px; align-items:center; margin: 10px 0; }
    .row label { flex: 0 0 96px; font-size: 12px; color: var(--muted); }
    .row input[type="range"] { flex: 1; }
    .val { flex: 0 0 58px; text-align:right; font-variant-numeric: tabular-nums; font-size: 12px; color: var(--text); }
    .buttons { display:flex; gap: 10px; margin-top: 12px; }
    button {
      flex: 1; border-radius: 12px; border: 1px solid var(--panel-border);
      background: rgba(255,255,255,0.06); color: var(--text);
      padding: 10px 12px; font-size: 12px; cursor: pointer;
      transition: transform 120ms ease, background 120ms ease;
    }
    button:hover { background: rgba(255,255,255,0.10); transform: translateY(-1px); }
    button:active { transform: translateY(0px); }
    .hint { margin-top: 10px; font-size: 11px; color: var(--muted); line-height: 1.35; }
    .hint kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 10px; padding: 2px 6px; border-radius: 7px;
      border: 1px solid var(--panel-border);
      background: rgba(255,255,255,0.05);
      color: var(--text);
    }
    .footer {
      position: fixed; right: 18px; bottom: 18px;
      padding: 10px 12px; border-radius: 14px;
      background: rgba(18, 28, 40, 0.45);
      border: 1px solid rgba(255,255,255,0.10);
      color: rgba(235, 245, 255, 0.68);
      box-shadow: 0 14px 42px rgba(0,0,0,0.30);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      font-size: 11px;
      user-select: none;
      z-index: 10;
    }
    .overlay {
      position: fixed; inset: 0; display: none;
      align-items: center; justify-content: center; padding: 22px;
      background: rgba(7, 17, 29, 0.92); color: rgba(235, 245, 255, 0.92);
      z-index: 50;
    }
    .overlay .card {
      width: min(760px, 100%);
      border: 1px solid rgba(255,255,255,0.14);
      border-radius: 16px;
      background: rgba(18, 28, 40, 0.55);
      box-shadow: 0 18px 55px rgba(0,0,0,0.35);
      padding: 16px;
    }
    .overlay h2 { margin: 0 0 10px 0; font-size: 14px; }
    .overlay pre {
      margin: 0; white-space: pre-wrap; word-break: break-word;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 12px; color: rgba(235, 245, 255, 0.80);
      line-height: 1.35;
    }
  </style>
</head>

<body>
  <div id="app"></div>

  <div class="hud" aria-label="Ocean Wave Simulation Controls">
    <div class="title">
      <h1>Ocean Wave Simulation</h1>
      <div class="badge">calm mode</div>
    </div>

    <div class="row">
      <label for="wind">Wind speed</label>
      <input id="wind" type="range" min="0" max="30" step="0.1" value="10" />
      <div class="val" id="windVal">10.0</div>
    </div>

    <div class="row">
      <label for="height">Wave height</label>
      <input id="height" type="range" min="0" max="3" step="0.01" value="1.0" />
      <div class="val" id="heightVal">1.00</div>
    </div>

    <div class="row">
      <label for="light">Lighting</label>
      <input id="light" type="range" min="0" max="1" step="0.001" value="0.55" />
      <div class="val" id="lightVal">0.55</div>
    </div>

    <div class="buttons">
      <button id="resetBtn" type="button">Reset</button>
      <button id="pauseBtn" type="button">Pause</button>
    </div>

    <div class="hint">
      Drag to look around. Press <kbd>R</kbd> to reset view, <kbd>Space</kbd> to pause.
    </div>
  </div>

  <div class="footer">Tip: Lower wind + slightly higher lighting gives a tranquil sunrise.</div>

  <div class="overlay" id="overlay">
    <div class="card">
      <h2>Ocean Wave Simulation error</h2>
      <pre id="overlayText"></pre>
    </div>
  </div>

  <!-- LOCAL libraries (put these files in ./vendor/) -->
  <script src="./vendor/three.min.js"></script>
  <script src="./vendor/OrbitControls.js"></script>

  <script>
    const overlay = document.getElementById("overlay");
    const overlayText = document.getElementById("overlayText");
    function showError(msg){
      console.error(msg);
      overlayText.textContent = String(msg);
      overlay.style.display = "flex";
    }

    try {
      if (!window.THREE) {
        throw new Error("THREE is not loaded. Make sure vendor/three.min.js exists and is committed to GitHub Pages.");
      }
      if (!THREE.OrbitControls) {
        throw new Error("OrbitControls is not loaded. Make sure vendor/OrbitControls.js exists and is committed.");
      }

      const ui = {
        wind: document.getElementById("wind"),
        height: document.getElementById("height"),
        light: document.getElementById("light"),
        windVal: document.getElementById("windVal"),
        heightVal: document.getElementById("heightVal"),
        lightVal: document.getElementById("lightVal"),
        resetBtn: document.getElementById("resetBtn"),
        pauseBtn: document.getElementById("pauseBtn"),
      };

      function fmt(n, d=2){ return Number(n).toFixed(d); }
      function syncLabels(){
        ui.windVal.textContent = fmt(ui.wind.value, 1);
        ui.heightVal.textContent = fmt(ui.height.value, 2);
        ui.lightVal.textContent = fmt(ui.light.value, 2);
      }
      ["input","change"].forEach(evt => {
        ui.wind.addEventListener(evt, syncLabels);
        ui.height.addEventListener(evt, syncLabels);
        ui.light.addEventListener(evt, syncLabels);
      });
      syncLabels();

      const isMobile = /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
      const DPR = Math.min(window.devicePixelRatio || 1, isMobile ? 1.25 : 2.0);
      const OCEAN_SEGMENTS = isMobile ? 180 : 420;

      const app = document.getElementById("app");
      const renderer = new THREE.WebGLRenderer({ antialias: !isMobile, powerPreference: "high-performance" });
      renderer.setPixelRatio(DPR);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 0.95;
      app.appendChild(renderer.domElement);

      const scene = new THREE.Scene();
      scene.fog = new THREE.FogExp2(0x07111d, 0.012);

      const camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 5000);
      camera.position.set(0, 22, 60);

      const controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.minDistance = 20;
      controls.maxDistance = 180;
      controls.maxPolarAngle = Math.PI * 0.49;

      // Sky
      const skyGeo = new THREE.SphereGeometry(2000, 32, 16);
      const skyMat = new THREE.ShaderMaterial({
        side: THREE.BackSide,
        uniforms: {
          uTop:    { value: new THREE.Color(0x0b2440) },
          uHorizon:{ value: new THREE.Color(0x09233a) },
          uBottom: { value: new THREE.Color(0x07111d) },
          uLight:  { value: parseFloat(ui.light.value) },
        },
        vertexShader: `
          varying vec3 vWorldPos;
          void main(){
            vec4 wp = modelMatrix * vec4(position, 1.0);
            vWorldPos = wp.xyz;
            gl_Position = projectionMatrix * viewMatrix * wp;
          }
        `,
        fragmentShader: `
          precision highp float;
          varying vec3 vWorldPos;
          uniform vec3 uTop, uHorizon, uBottom;
          uniform float uLight;
          void main(){
            float h = normalize(vWorldPos).y * 0.5 + 0.5;
            vec3 col = mix(uBottom, uHorizon, smoothstep(0.05, 0.55, h));
            col = mix(col, uTop, smoothstep(0.45, 1.0, h));
            col += vec3(0.06, 0.08, 0.10) * (uLight * 0.9);
            gl_FragColor = vec4(clamp(col,0.0,1.0), 1.0);
          }
        `
      });
      scene.add(new THREE.Mesh(skyGeo, skyMat));

      const ambient = new THREE.AmbientLight(0xbad7ff, 0.25);
      scene.add(ambient);

      const sun = new THREE.DirectionalLight(0xffffff, 1.1);
      sun.position.set(60, 80, 20);
      scene.add(sun);

      // Ocean
      const oceanGeo = new THREE.PlaneGeometry(1200, 1200, OCEAN_SEGMENTS, OCEAN_SEGMENTS);
      oceanGeo.rotateX(-Math.PI / 2);

      const oceanMat = new THREE.ShaderMaterial({
        uniforms: {
          uTime:   { value: 0 },
          uWind:   { value: parseFloat(ui.wind.value) },
          uHeight: { value: parseFloat(ui.height.value) },
          uLight:  { value: parseFloat(ui.light.value) },
          uSunDir: { value: new THREE.Vector3().copy(sun.position).normalize() },
          uCamPos: { value: new THREE.Vector3() },
          uFogColor: { value: new THREE.Color(0x07111d) },
          uFogDensity: { value: 0.012 },
        },
        vertexShader: `
          precision highp float;
          uniform float uTime, uWind, uHeight;
          varying vec3 vNormal;
          varying vec3 vWorldPos;

          vec3 gerstner(vec2 xz, vec2 dir, float steep, float amp, float freq, float speed, inout vec3 nAcc){
            float t = uTime * speed;
            float phase = freq * dot(dir, xz) + t;
            float s = sin(phase);
            float c = cos(phase);
            float qa = steep * amp;
            vec3 disp = vec3(dir.x * qa * c, amp * s, dir.y * qa * c);
            nAcc.x += -dir.x * qa * freq * s;
            nAcc.y +=  1.0 - (steep * amp * freq) * c * 0.15;
            nAcc.z += -dir.y * qa * freq * s;
            return disp;
          }

          void main(){
            vec3 pos = position;
            vec2 xz = pos.xz;

            float wind = max(uWind, 0.0);
            float H = uHeight;

            vec2 wdir = normalize(vec2(1.0, 0.35));
            vec3 nAcc = vec3(0.0, 1.0, 0.0);
            vec3 disp = vec3(0.0);

            vec2 d1 = normalize(wdir + vec2( 0.18, -0.06));
            vec2 d2 = normalize(wdir + vec2(-0.10,  0.14));
            vec2 d3 = normalize(wdir + vec2( 0.08,  0.22));
            vec2 d4 = normalize(wdir + vec2(-0.22, -0.05));
            vec2 d5 = normalize(wdir + vec2( 0.02, -0.28));

            float w = 0.12 + wind * 0.018;

            disp += gerstner(xz, d1, 0.55, 0.85 * H, 0.020, 1.05 * w, nAcc);
            disp += gerstner(xz, d2, 0.45, 0.55 * H, 0.035, 1.35 * w, nAcc);
            disp += gerstner(xz, d3, 0.35, 0.30 * H, 0.060, 1.75 * w, nAcc);
            disp += gerstner(xz, d4, 0.25, 0.18 * H, 0.090, 2.20 * w, nAcc);
            disp += gerstner(xz, d5, 0.18, 0.10 * H, 0.140, 2.80 * w, nAcc);

            pos += disp;
            vNormal = normalize(nAcc);

            vec4 wp = modelMatrix * vec4(pos, 1.0);
            vWorldPos = wp.xyz;
            gl_Position = projectionMatrix * viewMatrix * wp;
          }
        `,
        fragmentShader: `
          precision highp float;
          uniform float uLight;
          uniform vec3 uSunDir, uCamPos, uFogColor;
          uniform float uFogDensity;
          varying vec3 vNormal;
          varying vec3 vWorldPos;

          float fresnelSchlick(float cosTheta, float F0){
            return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
          }

          void main(){
            vec3 N = normalize(vNormal);
            vec3 V = normalize(uCamPos - vWorldPos);

            float depthHint = clamp((vWorldPos.y + 2.0) * 0.08, 0.0, 1.0);
            vec3 deep = vec3(0.02, 0.10, 0.18);
            vec3 shallow = vec3(0.05, 0.18, 0.24);
            vec3 baseCol = mix(deep, shallow, depthHint);

            float skyMix = clamp(N.y * 0.5 + 0.5, 0.0, 1.0);
            vec3 skyCol = mix(vec3(0.02, 0.07, 0.12), vec3(0.10, 0.22, 0.35), pow(skyMix, 1.2));

            vec3 L = normalize(uSunDir);
            vec3 H = normalize(L + V);
            float ndl = max(dot(N, L), 0.0);
            float ndh = max(dot(N, H), 0.0);

            float rough = mix(0.10, 0.04, uLight);
            float specPow = mix(60.0, 220.0, 1.0 - rough);
            float spec = pow(ndh, specPow) * (0.25 + uLight * 0.95);

            float cosTheta = clamp(dot(N, V), 0.0, 1.0);
            float F = fresnelSchlick(cosTheta, 0.02);

            vec3 col = baseCol;
            col = mix(col, skyCol, F * (0.55 + 0.25 * uLight));
            col += vec3(1.0, 0.95, 0.85) * spec * ndl;

            float foam = smoothstep(0.65, 0.92, 1.0 - N.y);
            col = mix(col, vec3(0.80, 0.90, 0.95), foam * 0.12);

            col = pow(col, vec3(0.92));

            float dist = length(uCamPos - vWorldPos);
            float fog = 1.0 - exp(-uFogDensity * uFogDensity * dist * dist);
            col = mix(col, uFogColor, clamp(fog, 0.0, 1.0));

            gl_FragColor = vec4(col, 1.0);
          }
        `
      });

      const ocean = new THREE.Mesh(oceanGeo, oceanMat);
      scene.add(ocean);

      let paused = false;

      function applyLighting(l){
        const t = THREE.MathUtils.clamp(l, 0, 1);
        const elev = THREE.MathUtils.lerp(0.10, 0.85, t);
        const azim = 0.35;
        const r = 120.0;

        sun.position.set(Math.cos(azim)*r, THREE.MathUtils.lerp(18, 90, elev), Math.sin(azim)*r);
        sun.intensity = THREE.MathUtils.lerp(0.55, 1.35, t);
        ambient.intensity = THREE.MathUtils.lerp(0.18, 0.35, t);

        skyMat.uniforms.uLight.value = t;
        oceanMat.uniforms.uSunDir.value.copy(sun.position).normalize();
        oceanMat.uniforms.uLight.value = t;
        renderer.toneMappingExposure = THREE.MathUtils.lerp(0.88, 1.05, t);
      }

      function applyWindAndHeight(){
        oceanMat.uniforms.uWind.value = parseFloat(ui.wind.value);
        oceanMat.uniforms.uHeight.value = parseFloat(ui.height.value);
      }

      ui.resetBtn.addEventListener("click", () => {
        ui.wind.value = "10";
        ui.height.value = "1.0";
        ui.light.value = "0.55";
        syncLabels();
        applyWindAndHeight();
        applyLighting(parseFloat(ui.light.value));
        controls.target.set(0,0,0);
        camera.position.set(0,22,60);
        controls.update();
      });

      ui.pauseBtn.addEventListener("click", () => {
        paused = !paused;
        ui.pauseBtn.textContent = paused ? "Resume" : "Pause";
      });

      ui.wind.addEventListener("input", () => { syncLabels(); applyWindAndHeight(); });
      ui.height.addEventListener("input", () => { syncLabels(); applyWindAndHeight(); });
      ui.light.addEventListener("input", () => { syncLabels(); applyLighting(parseFloat(ui.light.value)); });

      applyWindAndHeight();
      applyLighting(parseFloat(ui.light.value));

      const clock = new THREE.Clock();
      function tick(){
        requestAnimationFrame(tick);
        const dt = clock.getDelta();
        if (!paused) oceanMat.uniforms.uTime.value += dt;
        controls.update();
        oceanMat.uniforms.uCamPos.value.copy(camera.position);
        oceanMat.uniforms.uSunDir.value.copy(sun.position).normalize();
        renderer.render(scene, camera);
      }
      tick();

      window.addEventListener("resize", () => {
        renderer.setSize(window.innerWidth, window.innerHeight);
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
      });

    } catch (e) {
      showError(e && e.stack ? e.stack : e);
    }
  </script>
</body>
</html>
