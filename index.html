<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Ocean Wave Simulation</title>
  <style>
    :root{
      --panel-bg: rgba(18, 28, 40, 0.58);
      --panel-border: rgba(255,255,255,0.14);
      --text: rgba(235, 245, 255, 0.92);
      --muted: rgba(235, 245, 255, 0.70);
      --shadow: 0 18px 55px rgba(0,0,0,0.35);
      --radius: 18px;
    }
    html, body { height:100%; margin:0; background:#07111d; overflow:hidden; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; }
    #app { position: fixed; inset: 0; }
    canvas { display:block; width:100%; height:100%; }

    /* Cinematic overlays */
    .fx {
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 8;
      background:
        radial-gradient(circle at 62% 38%, rgba(255,255,255,0.16) 0%, rgba(255,255,255,0.06) 18%, rgba(0,0,0,0.00) 42%),
        radial-gradient(circle at 50% 50%, rgba(0,0,0,0.00) 36%, rgba(0,0,0,0.55) 76%, rgba(0,0,0,0.86) 100%);
      mix-blend-mode: multiply;
    }

    /* Grain */
    #grain {
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 9;
      opacity: 0.10;
      mix-blend-mode: overlay;
    }

    /* HUD */
    .hud {
      position: fixed;
      left: 18px;
      top: 18px;
      width: min(380px, calc(100vw - 36px));
      padding: 16px 16px 14px;
      border-radius: var(--radius);
      background: var(--panel-bg);
      border: 1px solid var(--panel-border);
      box-shadow: var(--shadow);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      color: var(--text);
      user-select: none;
      z-index: 10;
    }
    .title { display:flex; align-items:center; justify-content:space-between; gap: 10px; margin-bottom: 8px; }
    .title h1 { font-size: 15px; letter-spacing: 0.2px; margin:0; font-weight: 650; }
    .badges { display:flex; gap: 8px; align-items:center; }
    .badge {
      font-size: 11px; color: rgba(235,245,255,0.75);
      padding: 4px 10px; border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.04);
    }
    .badge.live{
      border-color: rgba(120, 255, 200, 0.22);
      background: rgba(120, 255, 200, 0.08);
      color: rgba(200, 255, 235, 0.90);
    }
    .desc {
      font-size: 11px;
      color: rgba(235,245,255,0.70);
      line-height: 1.35;
      margin-bottom: 10px;
    }

    .row { display:flex; gap: 12px; align-items:center; margin: 10px 0; }
    .row label { flex: 0 0 92px; font-size: 12px; color: var(--muted); }
    .row input[type="range"] { flex: 1; accent-color: rgb(120, 210, 255); }
    .val { flex: 0 0 58px; text-align:right; font-variant-numeric: tabular-nums; font-size: 12px; color: var(--text); }

    .buttons { display:flex; gap: 10px; margin-top: 12px; }
    button {
      flex: 1;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06);
      color: var(--text);
      padding: 9px 12px;
      font-size: 12px;
      cursor: pointer;
      transition: transform 120ms ease, background 120ms ease;
    }
    button:hover { background: rgba(255,255,255,0.10); transform: translateY(-1px); }
    button:active { transform: translateY(0px); }

    .hint {
      margin-top: 10px;
      font-size: 11px;
      color: rgba(235,245,255,0.62);
      line-height: 1.35;
    }
    .hint kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 7px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.05);
      color: rgba(235,245,255,0.90);
    }

    /* Error overlay */
    .overlay {
      position: fixed; inset: 0;
      display: none; align-items: center; justify-content: center;
      padding: 22px;
      background: rgba(7, 17, 29, 0.92);
      color: rgba(235, 245, 255, 0.92);
      z-index: 60;
    }
    .overlay .card {
      width: min(860px, 100%);
      border: 1px solid rgba(255,255,255,0.14);
      border-radius: 16px;
      background: rgba(18, 28, 40, 0.55);
      box-shadow: 0 18px 55px rgba(0,0,0,0.35);
      padding: 16px;
    }
    .overlay h2 { margin: 0 0 10px 0; font-size: 14px; }
    .overlay pre {
      margin: 0;
      white-space: pre-wrap;
      word-break: break-word;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 12px;
      color: rgba(235, 245, 255, 0.82);
      line-height: 1.35;
    }
  </style>
</head>

<body>
  <div id="app"></div>
  <div class="fx"></div>
  <canvas id="grain"></canvas>

  <div class="hud" aria-label="Ocean Wave Simulation Controls">
    <div class="title">
      <h1>Ocean Wave Simulation</h1>
      <div class="badges">
        <div class="badge live">Live</div>
      </div>
    </div>

    <div class="desc">
      Procedural ocean surface with real-time lighting. Adjust the elements below for a calmer or stormier sea.
    </div>

    <div class="row">
      <label for="wind">Wind speed</label>
      <input id="wind" type="range" min="0" max="30" step="0.1" value="12" />
      <div class="val" id="windVal">1.20×</div>
    </div>

    <div class="row">
      <label for="height">Wave height</label>
      <input id="height" type="range" min="0" max="3" step="0.01" value="1.0" />
      <div class="val" id="heightVal">1.00×</div>
    </div>

    <div class="row">
      <label for="light">Lighting</label>
      <input id="light" type="range" min="0" max="1" step="0.001" value="0.62" />
      <div class="val" id="lightVal">62%</div>
    </div>

    <div class="buttons">
      <button id="resetBtn" type="button">Reset</button>
      <button id="pauseBtn" type="button">Pause</button>
      <button id="fsBtn" type="button">Fullscreen</button>
    </div>

    <div class="hint">
      Drag to look around. Press <kbd>F</kbd> for fullscreen, <kbd>Space</kbd> to pause.
    </div>
  </div>

  <div class="overlay" id="overlay">
    <div class="card">
      <h2>Ocean Wave Simulation error</h2>
      <pre id="overlayText"></pre>
    </div>
  </div>

  <script type="module">
    const overlay = document.getElementById("overlay");
    const overlayText = document.getElementById("overlayText");
    function showError(err){
      const msg = (err && err.stack) ? err.stack : String(err);
      console.error(msg);
      overlayText.textContent = msg;
      overlay.style.display = "flex";
    }
    function hasWebGL(){
      try{
        const c = document.createElement("canvas");
        return !!(c.getContext("webgl2") || c.getContext("webgl") || c.getContext("experimental-webgl"));
      }catch(_){ return false; }
    }

    async function importFirst(urls){
      let lastErr = null;
      for (const u of urls){
        try { return await import(u); }
        catch(e){ lastErr = e; }
      }
      throw lastErr || new Error("Import failed");
    }

    // Grain (fast): draw small tile and scale
    const grain = document.getElementById("grain");
    const gctx = grain.getContext("2d", { alpha: true });
    const tile = document.createElement("canvas");
    tile.width = 220; tile.height = 220;
    const tctx = tile.getContext("2d", { alpha: true });
    let grainPattern = null;

    function regenTile(){
      const img = tctx.createImageData(tile.width, tile.height);
      const d = img.data;
      for (let i = 0; i < d.length; i += 4){
        const v = (Math.random() * 255) | 0;
        d[i+0] = v; d[i+1] = v; d[i+2] = v; d[i+3] = 255;
      }
      tctx.putImageData(img, 0, 0);
      grainPattern = gctx.createPattern(tile, "repeat");
    }

    function resizeGrain(){
      grain.width = Math.floor(window.innerWidth);
      grain.height = Math.floor(window.innerHeight);
    }
    function drawGrain(time){
      if (!grainPattern) return;
      gctx.clearRect(0,0,grain.width,grain.height);
      gctx.globalAlpha = 0.26;
      gctx.setTransform(1,0,0,1, (time*0.9)%tile.width, (time*0.6)%tile.height);
      gctx.fillStyle = grainPattern;
      gctx.fillRect(-tile.width, -tile.height, grain.width + tile.width*2, grain.height + tile.height*2);
      gctx.setTransform(1,0,0,1,0,0);
      gctx.globalAlpha = 1.0;
    }

    try{
      if (!hasWebGL()) throw new Error("WebGL not available. Enable hardware acceleration.");

      // Correct ESM imports (no fake vendor files)
      const THREE = await importFirst([
        "https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.js",
        "https://unpkg.com/three@0.164.1/build/three.module.js",
      ]);

      const { OrbitControls } = await importFirst([
        "https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/controls/OrbitControls.js",
        "https://unpkg.com/three@0.164.1/examples/jsm/controls/OrbitControls.js",
      ]);

      // UI
      const ui = {
        wind: document.getElementById("wind"),
        height: document.getElementById("height"),
        light: document.getElementById("light"),
        windVal: document.getElementById("windVal"),
        heightVal: document.getElementById("heightVal"),
        lightVal: document.getElementById("lightVal"),
        resetBtn: document.getElementById("resetBtn"),
        pauseBtn: document.getElementById("pauseBtn"),
        fsBtn: document.getElementById("fsBtn"),
      };
      function syncLabels(){
        ui.windVal.textContent = (Number(ui.wind.value) / 10).toFixed(2) + "×";
        ui.heightVal.textContent = Number(ui.height.value).toFixed(2) + "×";
        ui.lightVal.textContent = Math.round(Number(ui.light.value) * 100) + "%";
      }
      ["input","change"].forEach(evt => {
        ui.wind.addEventListener(evt, syncLabels);
        ui.height.addEventListener(evt, syncLabels);
        ui.light.addEventListener(evt, syncLabels);
      });
      syncLabels();

      // Renderer
      const app = document.getElementById("app");
      const isMobile = /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
      const dpr = Math.min(window.devicePixelRatio || 1, isMobile ? 1.25 : 2.0);

      const renderer = new THREE.WebGLRenderer({ antialias: !isMobile, powerPreference: "high-performance" });
      renderer.setPixelRatio(dpr);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1.05;
      app.appendChild(renderer.domElement);

      // Scene / Camera
      const scene = new THREE.Scene();
      const fogColor = new THREE.Color(0x07111d);
      scene.fog = new THREE.FogExp2(fogColor, 0.0036);

      const camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.05, 6000);
      camera.position.set(18, 3.4, 14);

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.06;
      controls.enablePan = false;
      controls.minDistance = 8;
      controls.maxDistance = 90;
      controls.minPolarAngle = 0.08;
      controls.maxPolarAngle = Math.PI * 0.46;
      controls.target.set(0, 0.7, 0);

      // Lighting
      const ambient = new THREE.AmbientLight(0xbad7ff, 0.22);
      scene.add(ambient);

      const sun = new THREE.DirectionalLight(0xffffff, 1.25);
      sun.position.set(55, 65, 8);
      scene.add(sun);

      // Sky dome with sun glow
      const skyGeo = new THREE.SphereGeometry(2400, 32, 18);
      const skyMat = new THREE.ShaderMaterial({
        side: THREE.BackSide,
        uniforms: {
          uTop:    { value: new THREE.Color(0x0b2a43) },
          uMid:    { value: new THREE.Color(0x0a2238) },
          uBottom: { value: new THREE.Color(0x07111d) },
          uSunDir: { value: new THREE.Vector3().copy(sun.position).normalize() },
          uLight:  { value: parseFloat(ui.light.value) },
        },
        vertexShader: `
          varying vec3 vDir;
          void main(){
            vDir = normalize((modelMatrix * vec4(position,1.0)).xyz);
            gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);
          }
        `,
        fragmentShader: `
          precision highp float;
          varying vec3 vDir;
          uniform vec3 uTop, uMid, uBottom;
          uniform vec3 uSunDir;
          uniform float uLight;

          void main(){
            float h = vDir.y * 0.5 + 0.5;
            vec3 col = mix(uBottom, uMid, smoothstep(0.00, 0.60, h));
            col = mix(col, uTop, smoothstep(0.30, 1.00, h));

            // Sun glow
            float sunDot = max(dot(normalize(vDir), normalize(uSunDir)), 0.0);
            float glow = pow(sunDot, 180.0) * (0.8 + 0.8*uLight);
            float halo = pow(sunDot, 28.0) * (0.12 + 0.25*uLight);
            col += vec3(1.0, 0.98, 0.92) * (glow + halo);

            // Subtle haze lift
            col += vec3(0.02,0.03,0.04) * (uLight*0.9);
            gl_FragColor = vec4(clamp(col,0.0,1.0), 1.0);
          }
        `
      });
      const sky = new THREE.Mesh(skyGeo, skyMat);
      scene.add(sky);

      // Ocean shader (geometry waves + fragment micro normal detail)
      const oceanSize = 1400;
      const segments = isMobile ? 240 : 420;
      const oceanGeo = new THREE.PlaneGeometry(oceanSize, oceanSize, segments, segments);
      oceanGeo.rotateX(-Math.PI/2);

      const oceanMat = new THREE.ShaderMaterial({
        transparent: false,
        uniforms: {
          uTime:   { value: 0 },
          uWind:   { value: parseFloat(ui.wind.value) },
          uHeight: { value: parseFloat(ui.height.value) },
          uLight:  { value: parseFloat(ui.light.value) },
          uSunDir: { value: new THREE.Vector3().copy(sun.position).normalize() },
          uCamPos: { value: new THREE.Vector3() },
          uFogColor: { value: fogColor },
          uFogDensity: { value: 0.0036 },
        },
        vertexShader: `
          precision highp float;
          uniform float uTime;
          uniform float uWind;
          uniform float uHeight;

          varying vec3 vWorldPos;
          varying vec2 vXZ;

          vec3 gerstner(vec2 xz, vec2 dir, float steep, float amp, float freq, float speed){
            float t = uTime * speed;
            float phase = freq * dot(dir, xz) + t;
            float s = sin(phase);
            float c = cos(phase);
            float qa = steep * amp;
            return vec3(dir.x * qa * c, amp * s, dir.y * qa * c);
          }

          void main(){
            vec3 pos = position;
            vec2 xz = pos.xz;

            float wind = max(uWind, 0.0);
            float H = uHeight;

            vec2 wdir = normalize(vec2(1.0, 0.32));
            vec2 d1 = normalize(wdir + vec2( 0.18, -0.06));
            vec2 d2 = normalize(wdir + vec2(-0.10,  0.14));
            vec2 d3 = normalize(wdir + vec2( 0.08,  0.22));
            vec2 d4 = normalize(wdir + vec2(-0.24, -0.05));

            float w = 0.11 + wind * 0.018;

            // Keep geometry waves medium frequency (detail will be in fragment normals)
            vec3 disp = vec3(0.0);
            disp += gerstner(xz, d1, 0.62, 0.95*H, 0.040, 1.00*w);
            disp += gerstner(xz, d2, 0.48, 0.55*H, 0.070, 1.35*w);
            disp += gerstner(xz, d3, 0.36, 0.28*H, 0.120, 1.85*w);
            disp += gerstner(xz, d4, 0.25, 0.16*H, 0.190, 2.35*w);

            pos += disp;

            vec4 wp = modelMatrix * vec4(pos, 1.0);
            vWorldPos = wp.xyz;
            vXZ = wp.xz;

            gl_Position = projectionMatrix * viewMatrix * wp;
          }
        `,
        fragmentShader: `
          precision highp float;

          uniform float uTime;
          uniform float uWind;
          uniform float uHeight;
          uniform float uLight;
          uniform vec3 uSunDir;
          uniform vec3 uCamPos;
          uniform vec3 uFogColor;
          uniform float uFogDensity;

          varying vec3 vWorldPos;
          varying vec2 vXZ;

          // Hash / noise
          float hash21(vec2 p){
            p = fract(p*vec2(123.34, 345.45));
            p += dot(p, p+34.345);
            return fract(p.x*p.y);
          }
          float noise(vec2 p){
            vec2 i = floor(p);
            vec2 f = fract(p);
            float a = hash21(i);
            float b = hash21(i+vec2(1,0));
            float c = hash21(i+vec2(0,1));
            float d = hash21(i+vec2(1,1));
            vec2 u = f*f*(3.0-2.0*f);
            return mix(a,b,u.x) + (c-a)*u.y*(1.0-u.x) + (d-b)*u.x*u.y;
          }
          float fbm(vec2 p){
            float v = 0.0;
            float a = 0.5;
            mat2 m = mat2(1.6,1.2,-1.2,1.6);
            for(int i=0;i<5;i++){
              v += a * noise(p);
              p = m*p;
              a *= 0.55;
            }
            return v;
          }

          // Height field for micro ripples (fragment detail)
          float rippleHeight(vec2 xz){
            float wind = max(uWind,0.0);
            float H = uHeight;
            float t = uTime * (0.35 + 0.02*wind);

            // directional ripples + fbm
            vec2 dir = normalize(vec2(1.0,0.32));
            float a = 0.06 + 0.010*wind;
            float f1 = fbm(xz*0.18 + dir* t*2.2);
            float f2 = fbm(xz*0.42 - dir* t*3.0);
            float f3 = fbm(xz*0.95 + vec2(t*1.7, -t*1.1));

            float rip = (f1*0.60 + f2*0.30 + f3*0.22) - 0.55;
            rip *= a * (0.55 + 0.55*H);

            // extra sparkle ripples
            float s1 = sin((xz.x*1.8 + xz.y*1.2)*0.9 + t*6.0);
            float s2 = sin((xz.x*2.4 - xz.y*1.9)*1.1 + t*4.5);
            rip += (s1*0.010 + s2*0.008) * (0.5 + 0.03*wind);

            return rip;
          }

          vec3 normalFromHeight(vec2 xz){
            // screen-space stable epsilon
            float e = 0.35;
            float hL = rippleHeight(xz - vec2(e,0));
            float hR = rippleHeight(xz + vec2(e,0));
            float hD = rippleHeight(xz - vec2(0,e));
            float hU = rippleHeight(xz + vec2(0,e));

            // gradient
            vec3 n = normalize(vec3(-(hR-hL), 2.0*e, -(hU-hD)));
            return n;
          }

          // GGX BRDF (simple)
          float D_GGX(float NoH, float a){
            float a2 = a*a;
            float d = (NoH*NoH)*(a2-1.0)+1.0;
            return a2 / (3.14159 * d*d);
          }
          float G_SchlickGGX(float NoV, float k){
            return NoV / (NoV*(1.0-k)+k);
          }
          float G_Smith(float NoV, float NoL, float k){
            return G_SchlickGGX(NoV,k)*G_SchlickGGX(NoL,k);
          }
          vec3 F_Schlick(vec3 F0, float VoH){
            return F0 + (1.0-F0)*pow(1.0-VoH,5.0);
          }

          void main(){
            vec3 V = normalize(uCamPos - vWorldPos);

            // Base geometric normal (mostly up), plus micro normal detail
            vec3 Ng = vec3(0.0, 1.0, 0.0);
            vec3 Nm = normalFromHeight(vXZ);

            // Blend strength depends on wind/height (more wind => more micro detail)
            float wind = max(uWind,0.0);
            float H = uHeight;
            float microStr = clamp(0.55 + 0.02*wind + 0.18*H, 0.55, 1.25);
            vec3 N = normalize(mix(Ng, Nm, microStr));

            vec3 L = normalize(uSunDir);
            vec3 Hn = normalize(L + V);

            float NoV = max(dot(N, V), 0.001);
            float NoL = max(dot(N, L), 0.0);
            float NoH = max(dot(N, Hn), 0.0);
            float VoH = max(dot(V, Hn), 0.0);

            // Water absorption colors (deep vs shallow)
            vec3 deep = vec3(0.01, 0.06, 0.11);
            vec3 shallow = vec3(0.05, 0.16, 0.20);

            // distance/haze gives "depth" cue
            float dist = length(uCamPos - vWorldPos);
            float depthHint = clamp(1.0 - exp(-dist*0.018), 0.0, 1.0);
            vec3 baseCol = mix(shallow, deep, depthHint);

            // Sky reflection approx (based on reflected view direction)
            vec3 R = reflect(-V, N);
            float skyMix = clamp(R.y*0.5+0.5, 0.0, 1.0);
            vec3 skyCol = mix(vec3(0.02,0.06,0.10), vec3(0.14,0.26,0.36), pow(skyMix, 1.2));

            // Fresnel
            vec3 F0 = vec3(0.02);
            vec3 F = F_Schlick(F0, VoH);

            // Roughness responds to wind (stormy => rougher => broader highlight)
            float rough = clamp(mix(0.040, 0.12, wind/30.0), 0.035, 0.14);
            rough = mix(rough, rough*0.72, uLight); // brighter lighting slightly sharper
            float a = rough*rough;

            float D = D_GGX(NoH, a);
            float k = (rough+1.0); k = (k*k)/8.0;
            float G = G_Smith(NoV, NoL, k);

            vec3 spec = (D*G*F) / max(4.0*NoV*NoL, 0.001);

            // Sun glint enhancer for sparkle
            float glint = pow(max(dot(R, L), 0.0), mix(90.0, 240.0, 1.0-rough));
            glint *= (0.15 + 0.85*uLight);

            // Foam: from slope + noise
            float slope = 1.0 - N.y;
            float foamN = fbm(vXZ*0.18 + uTime*0.45);
            float foam = smoothstep(0.22, 0.55, slope + foamN*0.35) * (0.10 + 0.25*H);

            // Final shading
            vec3 col = baseCol;

            // diffuse-ish (very small, mostly spec/reflect for water)
            col += baseCol * (0.04 + 0.06*uLight) * NoL;

            // reflection (Fresnel)
            col = mix(col, skyCol, clamp(F.x*0.85, 0.0, 1.0));

            // spec highlight
            col += spec * (0.75 + 1.15*uLight) * NoL;

            // glint sparkle
            col += vec3(1.0, 0.97, 0.90) * glint * (0.08 + 0.18*H);

            // foam tint
            col = mix(col, vec3(0.84,0.93,1.0), foam);

            // cinematic contrast
            col = pow(col, vec3(0.92));

            // fog (smooth horizon blend)
            float fog = 1.0 - exp(-uFogDensity*uFogDensity*dist*dist);
            col = mix(col, uFogColor, clamp(fog, 0.0, 1.0));

            gl_FragColor = vec4(col, 1.0);
          }
        `
      });

      const ocean = new THREE.Mesh(oceanGeo, oceanMat);
      ocean.position.y = 0.0;
      scene.add(ocean);

      // Keep ocean centered around camera for "infinite" feel
      function centerOcean(){
        ocean.position.x = camera.position.x;
        ocean.position.z = camera.position.z;
      }

      // hooks
      let paused = false;

      function applyLighting(l){
        const t = THREE.MathUtils.clamp(l, 0, 1);

        // sun elevation/brightness
        const elev = THREE.MathUtils.lerp(0.10, 0.82, t);
        const azim = 0.30;
        const r = 140.0;
        const x = Math.cos(azim) * r;
        const z = Math.sin(azim) * r;
        const y = THREE.MathUtils.lerp(12, 92, elev);

        sun.position.set(x, y, z);
        sun.intensity = THREE.MathUtils.lerp(0.70, 1.55, t);
        ambient.intensity = THREE.MathUtils.lerp(0.18, 0.32, t);

        skyMat.uniforms.uSunDir.value.copy(sun.position).normalize();
        skyMat.uniforms.uLight.value = t;

        oceanMat.uniforms.uLight.value = t;
        oceanMat.uniforms.uSunDir.value.copy(sun.position).normalize();

        renderer.toneMappingExposure = THREE.MathUtils.lerp(0.95, 1.12, t);
      }

      function applyWindAndHeight(){
        oceanMat.uniforms.uWind.value = parseFloat(ui.wind.value);
        oceanMat.uniforms.uHeight.value = parseFloat(ui.height.value);
      }

      ui.resetBtn.addEventListener("click", () => {
        ui.wind.value = "12";
        ui.height.value = "1.0";
        ui.light.value = "0.62";
        syncLabels();
        applyWindAndHeight();
        applyLighting(parseFloat(ui.light.value));

        controls.target.set(0, 0.7, 0);
        camera.position.set(18, 3.4, 14);
        controls.update();
      });

      ui.pauseBtn.addEventListener("click", () => {
        paused = !paused;
        ui.pauseBtn.textContent = paused ? "Resume" : "Pause";
      });

      async function toggleFullscreen(){
        if (!document.fullscreenElement){
          await document.documentElement.requestFullscreen?.();
        }else{
          await document.exitFullscreen?.();
        }
      }
      ui.fsBtn.addEventListener("click", toggleFullscreen);

      ui.wind.addEventListener("input", applyWindAndHeight);
      ui.height.addEventListener("input", applyWindAndHeight);
      ui.light.addEventListener("input", () => applyLighting(parseFloat(ui.light.value)));

      window.addEventListener("keydown", (e) => {
        if (e.code === "Space"){
          e.preventDefault();
          paused = !paused;
          ui.pauseBtn.textContent = paused ? "Resume" : "Pause";
        }
        if (e.key.toLowerCase() === "f"){
          toggleFullscreen();
        }
      });

      // init
      applyWindAndHeight();
      applyLighting(parseFloat(ui.light.value));
      resizeGrain(); regenTile();

      // loop
      const clock = new THREE.Clock();
      let grainAcc = 0;

      function tick(){
        requestAnimationFrame(tick);

        const dt = clock.getDelta();
        if (!paused) oceanMat.uniforms.uTime.value += dt;

        oceanMat.uniforms.uCamPos.value.copy(camera.position);
        oceanMat.uniforms.uSunDir.value.copy(sun.position).normalize();

        controls.update();
        centerOcean();

        renderer.render(scene, camera);

        grainAcc += dt;
        if (grainAcc > 0.08){
          regenTile();
          grainAcc = 0;
        }
        drawGrain(performance.now()*0.001);
      }
      tick();

      // resize
      function onResize(){
        renderer.setSize(window.innerWidth, window.innerHeight);
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        resizeGrain();
      }
      window.addEventListener("resize", onResize);

    } catch (e) {
      showError(e);
    }
  </script>
</body>
</html>
