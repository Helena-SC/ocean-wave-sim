<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Ocean Wave Simulation</title>
  <style>
    :root{
      --panel-bg: rgba(18, 28, 40, 0.58);
      --panel-border: rgba(255,255,255,0.14);
      --text: rgba(235, 245, 255, 0.92);
      --muted: rgba(235, 245, 255, 0.70);
      --shadow: 0 18px 55px rgba(0,0,0,0.35);
      --radius: 18px;
    }
    html, body { height:100%; margin:0; background:#07111d; overflow:hidden; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; }
    #app { position: fixed; inset: 0; }
    canvas { display:block; width:100%; height:100%; }

    /* Cinematic overlays (vignette + soft spotlight) */
    .fx {
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 8;
      background:
        radial-gradient(circle at 62% 38%, rgba(255,255,255,0.16) 0%, rgba(255,255,255,0.06) 18%, rgba(0,0,0,0.00) 42%),
        radial-gradient(circle at 50% 50%, rgba(0,0,0,0.00) 36%, rgba(0,0,0,0.55) 76%, rgba(0,0,0,0.86) 100%);
      mix-blend-mode: multiply;
    }

    /* Grain canvas (subtle film grain) */
    #grain {
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 9;
      opacity: 0.085;
      mix-blend-mode: overlay;
    }

    /* HUD */
    .hud {
      position: fixed;
      left: 18px;
      top: 18px;
      width: min(380px, calc(100vw - 36px));
      padding: 16px 16px 14px;
      border-radius: var(--radius);
      background: var(--panel-bg);
      border: 1px solid var(--panel-border);
      box-shadow: var(--shadow);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      color: var(--text);
      user-select: none;
      z-index: 10;
    }
    .title { display:flex; align-items:center; justify-content:space-between; gap: 10px; margin-bottom: 8px; }
    .title h1 { font-size: 15px; letter-spacing: 0.2px; margin:0; font-weight: 650; }
    .badges { display:flex; gap: 8px; align-items:center; }
    .badge {
      font-size: 11px; color: rgba(235,245,255,0.75);
      padding: 4px 10px; border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.04);
    }
    .badge.live{
      border-color: rgba(120, 255, 200, 0.22);
      background: rgba(120, 255, 200, 0.08);
      color: rgba(200, 255, 235, 0.90);
    }
    .desc {
      font-size: 11px;
      color: rgba(235,245,255,0.70);
      line-height: 1.35;
      margin-bottom: 10px;
    }

    .row { display:flex; gap: 12px; align-items:center; margin: 10px 0; }
    .row label { flex: 0 0 92px; font-size: 12px; color: var(--muted); }
    .row input[type="range"] { flex: 1; accent-color: rgb(120, 210, 255); }
    .val { flex: 0 0 58px; text-align:right; font-variant-numeric: tabular-nums; font-size: 12px; color: var(--text); }

    .buttons { display:flex; gap: 10px; margin-top: 12px; }
    button {
      flex: 1;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06);
      color: var(--text);
      padding: 9px 12px;
      font-size: 12px;
      cursor: pointer;
      transition: transform 120ms ease, background 120ms ease;
    }
    button:hover { background: rgba(255,255,255,0.10); transform: translateY(-1px); }
    button:active { transform: translateY(0px); }

    .hint {
      margin-top: 10px;
      font-size: 11px;
      color: rgba(235,245,255,0.62);
      line-height: 1.35;
    }
    .hint kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 7px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.05);
      color: rgba(235,245,255,0.90);
    }

    /* Error overlay */
    .overlay {
      position: fixed; inset: 0;
      display: none; align-items: center; justify-content: center;
      padding: 22px;
      background: rgba(7, 17, 29, 0.92);
      color: rgba(235, 245, 255, 0.92);
      z-index: 60;
    }
    .overlay .card {
      width: min(860px, 100%);
      border: 1px solid rgba(255,255,255,0.14);
      border-radius: 16px;
      background: rgba(18, 28, 40, 0.55);
      box-shadow: 0 18px 55px rgba(0,0,0,0.35);
      padding: 16px;
    }
    .overlay h2 { margin: 0 0 10px 0; font-size: 14px; }
    .overlay pre {
      margin: 0;
      white-space: pre-wrap;
      word-break: break-word;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 12px;
      color: rgba(235, 245, 255, 0.82);
      line-height: 1.35;
    }
  </style>
</head>

<body>
  <div id="app"></div>
  <div class="fx"></div>
  <canvas id="grain"></canvas>

  <div class="hud" aria-label="Ocean Wave Simulation Controls">
    <div class="title">
      <h1>Ocean Wave Simulation</h1>
      <div class="badges">
        <div class="badge live">Live</div>
      </div>
    </div>

    <div class="desc">
      Calming, procedural ocean with moonlight and subtle stars. Adjust wind and wave height.
    </div>

    <div class="row">
      <label for="wind">Wind speed</label>
      <input id="wind" type="range" min="0" max="30" step="0.1" value="12" />
      <div class="val" id="windVal">1.20×</div>
    </div>

    <div class="row">
      <label for="height">Wave height</label>
      <input id="height" type="range" min="0" max="3" step="0.01" value="1.0" />
      <div class="val" id="heightVal">1.00×</div>
    </div>

    <div class="row">
      <label for="light">Lighting</label>
      <input id="light" type="range" min="0" max="1" step="0.001" value="0.62" />
      <div class="val" id="lightVal">62%</div>
    </div>

    <div class="buttons">
      <button id="resetBtn" type="button">Reset</button>
      <button id="pauseBtn" type="button">Pause</button>
      <button id="fsBtn" type="button">Fullscreen</button>
    </div>

    <div class="hint">
      Drag to look around. Wheel to zoom. Press <kbd>F</kbd> for fullscreen, <kbd>Space</kbd> to pause.
    </div>
  </div>

  <div class="overlay" id="overlay">
    <div class="card">
      <h2>Ocean Wave Simulation error</h2>
      <pre id="overlayText"></pre>
    </div>
  </div>

  <!-- IMPORTANT: Use UMD build so GitHub Pages does NOT need module imports -->
  <script src="./vendor/three.min.js"></script>

  <script>
    (function(){
      const overlay = document.getElementById("overlay");
      const overlayText = document.getElementById("overlayText");
      function showError(err){
        const msg = (err && err.stack) ? err.stack : String(err);
        console.error(msg);
        overlayText.textContent = msg;
        overlay.style.display = "flex";
      }
      function hasWebGL(){
        try{
          const c = document.createElement("canvas");
          return !!(c.getContext("webgl2") || c.getContext("webgl") || c.getContext("experimental-webgl"));
        }catch(_){ return false; }
      }

      // --- Grain ---
      const grain = document.getElementById("grain");
      const gctx = grain.getContext("2d", { alpha: true });
      function resizeGrain(){
        grain.width = Math.floor(window.innerWidth);
        grain.height = Math.floor(window.innerHeight);
      }
      function drawGrain(){
        const w = grain.width, h = grain.height;
        const img = gctx.createImageData(w, h);
        const d = img.data;
        // sparse grain for perf
        for (let i = 0; i < d.length; i += 20){
          const v = (Math.random() * 255) | 0;
          d[i+0] = v; d[i+1] = v; d[i+2] = v; d[i+3] = 255;
        }
        gctx.putImageData(img, 0, 0);
      }

      try{
        if (!hasWebGL()) throw new Error("WebGL not available. Enable hardware acceleration.");
        if (!window.THREE) throw new Error("THREE is not loaded. Ensure vendor/three.min.js exists and is committed.");

        const THREE = window.THREE;

        // ---------- UI ----------
        const ui = {
          wind: document.getElementById("wind"),
          height: document.getElementById("height"),
          light: document.getElementById("light"),
          windVal: document.getElementById("windVal"),
          heightVal: document.getElementById("heightVal"),
          lightVal: document.getElementById("lightVal"),
          resetBtn: document.getElementById("resetBtn"),
          pauseBtn: document.getElementById("pauseBtn"),
          fsBtn: document.getElementById("fsBtn"),
        };

        function syncLabels(){
          ui.windVal.textContent = (Number(ui.wind.value) / 10).toFixed(2) + "×";
          ui.heightVal.textContent = Number(ui.height.value).toFixed(2) + "×";
          ui.lightVal.textContent = Math.round(Number(ui.light.value) * 100) + "%";
        }
        ["input","change"].forEach(evt => {
          ui.wind.addEventListener(evt, syncLabels);
          ui.height.addEventListener(evt, syncLabels);
          ui.light.addEventListener(evt, syncLabels);
        });
        syncLabels();

        // ---------- Renderer ----------
        const app = document.getElementById("app");
        const isMobile = /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
        const dpr = Math.min(window.devicePixelRatio || 1, isMobile ? 1.25 : 2.0);

        const renderer = new THREE.WebGLRenderer({ antialias: !isMobile, powerPreference: "high-performance" });
        renderer.setPixelRatio(dpr);
        renderer.setSize(window.innerWidth, window.innerHeight);

        // three r152+ uses outputColorSpace
        if (renderer.outputColorSpace !== undefined) renderer.outputColorSpace = THREE.SRGBColorSpace;
        else renderer.outputEncoding = THREE.sRGBEncoding;

        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.05;

        app.appendChild(renderer.domElement);

        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x07111d, 0.0038);

        // Cinematic camera
        const camera = new THREE.PerspectiveCamera(52, window.innerWidth / window.innerHeight, 0.05, 5000);

        // ---------- Hand-rolled orbit controls ----------
        const orbit = {
          target: new THREE.Vector3(0, 1.2, 0),
          radius: 26,
          yaw: 1.10,
          pitch: 0.18,
          minRadius: 10,
          maxRadius: 120,
          minPitch: 0.06,
          maxPitch: Math.PI * 0.40,
          dragging: false,
          lastX: 0,
          lastY: 0,
          speed: 0.0068
        };
        function updateCamera(){
          const cp = Math.cos(orbit.pitch), sp = Math.sin(orbit.pitch);
          const cy = Math.cos(orbit.yaw),   sy = Math.sin(orbit.yaw);
          const x = orbit.radius * cp * cy;
          const z = orbit.radius * cp * sy;
          const y = orbit.radius * sp;
          camera.position.set(orbit.target.x + x, orbit.target.y + y, orbit.target.z + z);
          camera.lookAt(orbit.target);
        }
        updateCamera();

        renderer.domElement.style.touchAction = "none";
        renderer.domElement.addEventListener("pointerdown", (e) => {
          orbit.dragging = true;
          orbit.lastX = e.clientX; orbit.lastY = e.clientY;
          renderer.domElement.setPointerCapture(e.pointerId);
        });
        renderer.domElement.addEventListener("pointermove", (e) => {
          if (!orbit.dragging) return;
          const dx = e.clientX - orbit.lastX;
          const dy = e.clientY - orbit.lastY;
          orbit.lastX = e.clientX; orbit.lastY = e.clientY;

          orbit.yaw   -= dx * orbit.speed;
          orbit.pitch -= dy * orbit.speed;
          orbit.pitch = Math.max(orbit.minPitch, Math.min(orbit.maxPitch, orbit.pitch));
          updateCamera();
        });
        renderer.domElement.addEventListener("pointerup", (e) => {
          orbit.dragging = false;
          try{ renderer.domElement.releasePointerCapture(e.pointerId); }catch(_){}
        });
        renderer.domElement.addEventListener("wheel", (e) => {
          e.preventDefault();
          const s = (e.deltaY > 0) ? 1.06 : 0.94;
          orbit.radius = Math.max(orbit.minRadius, Math.min(orbit.maxRadius, orbit.radius * s));
          updateCamera();
        }, { passive: false });

        // ---------- Lights (moon + subtle fill) ----------
        const ambient = new THREE.AmbientLight(0xbad7ff, 0.18);
        scene.add(ambient);

        const moonLight = new THREE.DirectionalLight(0xe6f1ff, 1.25);
        moonLight.position.set(60, 80, 25);
        scene.add(moonLight);

        // optional very dim rim (just to lift blacks)
        const rim = new THREE.DirectionalLight(0x8fb3d9, 0.25);
        rim.position.set(-80, 30, -40);
        scene.add(rim);

        // ---------- SKY: gradient + stars + moon disc ----------
        const skyGeo = new THREE.SphereGeometry(2200, 48, 24);
        const skyMat = new THREE.ShaderMaterial({
          side: THREE.BackSide,
          uniforms: {
            uTime: { value: 0 },
            uLight: { value: parseFloat(ui.light.value) },
            uMoonDir: { value: new THREE.Vector3().copy(moonLight.position).normalize() },
            uTop: { value: new THREE.Color(0x0b2a43) },
            uMid: { value: new THREE.Color(0x071b2e) },
            uBottom: { value: new THREE.Color(0x050b14) },
          },
          vertexShader: `
            varying vec3 vDir;
            void main(){
              vec3 wpos = (modelMatrix * vec4(position,1.0)).xyz;
              vDir = normalize(wpos);
              gl_Position = projectionMatrix * viewMatrix * vec4(wpos, 1.0);
            }
          `,
          fragmentShader: `
            precision highp float;
            varying vec3 vDir;
            uniform float uTime;
            uniform float uLight;
            uniform vec3 uMoonDir;
            uniform vec3 uTop, uMid, uBottom;

            float hash(vec2 p){
              p = fract(p * vec2(123.34, 456.21));
              p += dot(p, p + 34.345);
              return fract(p.x * p.y);
            }
            float starField(vec3 d){
              // project to 2D
              vec2 uv = d.xz / (abs(d.y) + 1.2);
              uv *= 220.0;
              float h = hash(floor(uv));
              float s = smoothstep(0.9975, 1.0, h);
              float tw = 0.6 + 0.4 * sin(uTime * 1.7 + h * 40.0);
              return s * tw;
            }
            void main(){
              float h = clamp(vDir.y * 0.5 + 0.5, 0.0, 1.0);

              // base gradient
              vec3 col = mix(uBottom, uMid, smoothstep(0.00, 0.55, h));
              col = mix(col, uTop,    smoothstep(0.35, 1.00, h));

              // subtle high-alt haze
              col += vec3(0.02,0.03,0.04) * smoothstep(0.55, 1.0, h) * (0.6 + 0.6*uLight);

              // stars (more visible when darker)
              float stars = starField(vDir) * (1.0 - uLight) * 1.2;
              col += vec3(0.9, 0.95, 1.0) * stars;

              // moon disc + halo
              float md = clamp(dot(normalize(vDir), normalize(uMoonDir)), 0.0, 1.0);
              float moonCore = smoothstep(0.9994, 1.0, md);
              float moonHalo = smoothstep(0.985, 1.0, md) * 0.45;
              vec3 moonCol = vec3(0.92, 0.96, 1.00);

              col += moonCol * (moonCore * 2.4 + moonHalo);

              // mild vignette to keep calming
              float v = smoothstep(0.0, 0.7, h);
              col *= (0.90 + 0.10 * v);

              gl_FragColor = vec4(clamp(col,0.0,1.0), 1.0);
            }
          `
        });
        scene.add(new THREE.Mesh(skyGeo, skyMat));

        // ---------- OCEAN ----------
        const oceanSize = 1200;
        const segments = isMobile ? 220 : 360;
        const oceanGeo = new THREE.PlaneGeometry(oceanSize, oceanSize, segments, segments);
        oceanGeo.rotateX(-Math.PI/2);

        const oceanMat = new THREE.ShaderMaterial({
          uniforms: {
            uTime:   { value: 0 },
            uWind:   { value: parseFloat(ui.wind.value) },
            uHeight: { value: parseFloat(ui.height.value) },
            uLight:  { value: parseFloat(ui.light.value) },
            uMoonDir:{ value: new THREE.Vector3().copy(moonLight.position).normalize() },
            uRimDir: { value: new THREE.Vector3().copy(rim.position).normalize() },
            uCamPos: { value: new THREE.Vector3() },
            uFogColor: { value: new THREE.Color(0x07111d) },
            uFogDensity: { value: 0.0038 },
          },
          vertexShader: `
            precision highp float;

            uniform float uTime;
            uniform float uWind;
            uniform float uHeight;

            varying vec3 vWorldPos;
            varying vec3 vN;
            varying float vH;

            // Gerstner wave with analytic derivatives for better normals
            void wave(in vec2 xz, in vec2 dir, in float steep, in float amp, in float freq, in float speed,
                      inout vec3 p, inout vec3 dPx, inout vec3 dPz)
            {
              float t = uTime * speed;
              float phase = freq * dot(dir, xz) + t;

              float s = sin(phase);
              float c = cos(phase);

              float qa = steep * amp;

              // displacement
              p.x += dir.x * qa * c;
              p.y += amp * s;
              p.z += dir.y * qa * c;

              // partial derivatives (approx, enough to enrich lighting)
              // d/dx
              float dphdx = freq * dir.x;
              dPx.x += -dir.x * qa * s * dphdx;
              dPx.y +=  amp * c * dphdx;
              dPx.z += -dir.y * qa * s * dphdx;

              // d/dz
              float dphdz = freq * dir.y;
              dPz.x += -dir.x * qa * s * dphdz;
              dPz.y +=  amp * c * dphdz;
              dPz.z += -dir.y * qa * s * dphdz;
            }

            void main(){
              vec3 p = position;
              vec2 xz = p.xz;

              float wind = max(uWind, 0.0);
              float H = uHeight;

              vec2 wdir = normalize(vec2(1.0, 0.34));
              vec2 d1 = normalize(wdir + vec2( 0.18, -0.06));
              vec2 d2 = normalize(wdir + vec2(-0.10,  0.14));
              vec2 d3 = normalize(wdir + vec2( 0.08,  0.22));
              vec2 d4 = normalize(wdir + vec2(-0.22, -0.05));
              vec2 d5 = normalize(wdir + vec2( 0.02, -0.28));

              float baseSpeed = 0.10 + wind * 0.018;

              // start derivatives as basis vectors
              vec3 dPx = vec3(1.0, 0.0, 0.0);
              vec3 dPz = vec3(0.0, 0.0, 1.0);

              // multi-scale waves (more “layered”)
              wave(xz, d1, 0.65, 1.05*H, 0.035, 1.00*baseSpeed, p, dPx, dPz);
              wave(xz, d2, 0.55, 0.70*H, 0.060, 1.35*baseSpeed, p, dPx, dPz);
              wave(xz, d3, 0.42, 0.40*H, 0.110, 1.85*baseSpeed, p, dPx, dPz);
              wave(xz, d4, 0.30, 0.24*H, 0.170, 2.35*baseSpeed, p, dPx, dPz);
              wave(xz, d5, 0.22, 0.14*H, 0.260, 3.00*baseSpeed, p, dPx, dPz);

              // tiny vertical ripples (adds sparkle)
              float rt = uTime * (1.2 + wind*0.02);
              float r1 = sin( (xz.x*1.50 + xz.y*1.15)*0.95 + rt*2.2 );
              float r2 = sin( (xz.x*2.20 - xz.y*1.65)*1.10 + rt*1.8 );
              float micro = (r1*0.10 + r2*0.08) * (0.25 + 0.02*wind) * (0.40 + 0.50*H);
              p.y += micro;

              // normal from derivatives
              vec3 N = normalize(cross(dPz, dPx));

              vec4 wp = modelMatrix * vec4(p, 1.0);
              vWorldPos = wp.xyz;
              vN = N;
              vH = p.y;

              gl_Position = projectionMatrix * viewMatrix * wp;
            }
          `,
          fragmentShader: `
            precision highp float;

            uniform float uTime;
            uniform float uWind;
            uniform float uHeight;
            uniform float uLight;
            uniform vec3 uMoonDir;
            uniform vec3 uRimDir;
            uniform vec3 uCamPos;
            uniform vec3 uFogColor;
            uniform float uFogDensity;

            varying vec3 vWorldPos;
            varying vec3 vN;
            varying float vH;

            float hash(vec2 p){
              p = fract(p * vec2(123.34, 456.21));
              p += dot(p, p + 34.345);
              return fract(p.x * p.y);
            }
            float noise(vec2 p){
              vec2 i = floor(p);
              vec2 f = fract(p);
              float a = hash(i);
              float b = hash(i + vec2(1.0, 0.0));
              float c = hash(i + vec2(0.0, 1.0));
              float d = hash(i + vec2(1.0, 1.0));
              vec2 u = f*f*(3.0-2.0*f);
              return mix(a, b, u.x) + (c - a)*u.y*(1.0 - u.x) + (d - b)*u.x*u.y;
            }
            float fbm(vec2 p){
              float v = 0.0;
              float a = 0.55;
              for(int i=0;i<5;i++){
                v += a * noise(p);
                p *= 2.02;
                a *= 0.52;
              }
              return v;
            }

            float fresnelSchlick(float cosTheta, float F0){
              return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
            }

            vec3 skyColor(vec3 dir){
              // simple procedural sky used for reflections (matches sky mood)
              float h = clamp(dir.y * 0.5 + 0.5, 0.0, 1.0);
              vec3 bottom = vec3(0.02,0.03,0.05);
              vec3 mid    = vec3(0.04,0.10,0.16);
              vec3 top    = vec3(0.06,0.18,0.26);
              vec3 col = mix(bottom, mid, smoothstep(0.00, 0.55, h));
              col = mix(col, top, smoothstep(0.35, 1.00, h));

              // moon glow
              float md = clamp(dot(normalize(dir), normalize(uMoonDir)), 0.0, 1.0);
              float halo = smoothstep(0.97, 1.0, md) * 0.55;
              col += vec3(0.10,0.12,0.14) * halo;

              return col;
            }

            void main(){
              vec3 N = normalize(vN);
              vec3 V = normalize(uCamPos - vWorldPos);

              // add micro-normal detail in fragment (key for layered ripples)
              vec2 p = vWorldPos.xz * 0.08;
              float t = uTime * (0.35 + 0.015*uWind);
              float n = fbm(p + vec2(t, -t));
              float n2 = fbm(p*1.9 + vec2(-t*1.2, t*1.1));
              float m = (n*0.65 + n2*0.35);

              // approximate gradient for bump
              float eps = 0.22;
              float nx = fbm(p + vec2(eps, 0.0) + vec2(t, -t));
              float nz = fbm(p + vec2(0.0, eps) + vec2(t, -t));
              vec3 bump = normalize(vec3((nx - n), 0.35, (nz - n)));

              float bumpStrength = 0.55 + 0.02*uWind + 0.10*uHeight;
              N = normalize(mix(N, bump, clamp(bumpStrength, 0.0, 1.0)));

              vec3 Lm = normalize(uMoonDir);
              vec3 Lr = normalize(uRimDir);

              // base water color (depth-ish)
              vec3 deep = vec3(0.02, 0.07, 0.12);
              vec3 shallow = vec3(0.04, 0.15, 0.18);

              float facing = clamp(N.y * 0.5 + 0.5, 0.0, 1.0);
              vec3 baseCol = mix(deep, shallow, facing);

              // reflection
              vec3 R = reflect(-V, N);
              vec3 sky = skyColor(R);

              // fresnel
              float cosTheta = clamp(dot(N, V), 0.0, 1.0);
              float F = fresnelSchlick(cosTheta, 0.02);

              // specular (moon)
              vec3 Hm = normalize(Lm + V);
              float ndh = max(dot(N, Hm), 0.0);
              float ndl = max(dot(N, Lm), 0.0);

              // calmer look: keep roughness not too sharp, but still sparkly
              float wind01 = clamp(uWind / 30.0, 0.0, 1.0);
              float rough = mix(0.10, 0.035, wind01);
              float specPow = mix(90.0, 420.0, 1.0 - rough);
              float spec = pow(ndh, specPow) * (0.18 + 1.25*uLight) * ndl;

              // moon reflection streak (very “realistic” cue)
              float moonAlign = pow(clamp(dot(R, Lm), 0.0, 1.0), 80.0);
              float shimmer = pow(clamp(1.0 - N.y, 0.0, 1.0), 2.0);
              vec3 moonCol = vec3(0.92, 0.96, 1.00);
              vec3 moonStreak = moonCol * moonAlign * (0.6 + 1.2*shimmer) * (0.35 + 0.65*uLight);

              // foam: crest (height) + slope (normal)
              float crest = smoothstep(0.55, 1.10, vH * (0.9 + 0.2*wind01));
              float slope = smoothstep(0.55, 0.92, 1.0 - N.y);
              float foam = clamp(crest * 0.9 + slope * 0.55, 0.0, 1.0);

              // tiny glitter (sparkle dots)
              float g = noise(vWorldPos.xz * 3.2 + vec2(uTime*0.6, -uTime*0.5));
              float glitter = smoothstep(0.86, 1.0, g) * (0.25 + 0.6*wind01) * ndl;
              vec3 glitterCol = moonCol * glitter * 0.55;

              vec3 col = baseCol;

              // mix reflection with fresnel
              col = mix(col, sky, F * (0.55 + 0.25*uLight));

              // spec + streak + foam + glitter
              col += moonCol * spec;
              col += moonStreak;
              col = mix(col, vec3(0.86, 0.93, 1.00), foam * 0.22);
              col += glitterCol;

              // gentle contrast (calming)
              col = pow(col, vec3(0.93));

              // fog
              float dist = length(uCamPos - vWorldPos);
              float fog = 1.0 - exp(-uFogDensity * uFogDensity * dist * dist);
              col = mix(col, uFogColor, clamp(fog, 0.0, 1.0));

              gl_FragColor = vec4(clamp(col,0.0,1.0), 1.0);
            }
          `
        });

        const ocean = new THREE.Mesh(oceanGeo, oceanMat);
        ocean.position.y = 0.0;
        scene.add(ocean);

        // ---------- Runtime hooks ----------
        let paused = false;

        function applyLighting(l){
          const t = THREE.MathUtils.clamp(l, 0, 1);

          // moon position (slight movement with slider for mood)
          const elev = THREE.MathUtils.lerp(0.18, 0.72, t);
          const azim = 0.38;
          const r = 140.0;
          const x = Math.cos(azim) * r;
          const z = Math.sin(azim) * r;
          const y = THREE.MathUtils.lerp(22, 92, elev);

          moonLight.position.set(x, y, z);
          moonLight.intensity = THREE.MathUtils.lerp(0.85, 1.55, t);
          ambient.intensity = THREE.MathUtils.lerp(0.14, 0.26, t);

          // fog slightly lighter with higher lighting
          const fogD = THREE.MathUtils.lerp(0.0042, 0.0032, t);
          scene.fog.density = fogD;
          oceanMat.uniforms.uFogDensity.value = fogD;

          // exposure
          renderer.toneMappingExposure = THREE.MathUtils.lerp(0.98, 1.10, t);

          // sky palette shifts a bit
          skyMat.uniforms.uLight.value = t;
          skyMat.uniforms.uMoonDir.value.copy(moonLight.position).normalize();

          oceanMat.uniforms.uLight.value = t;
          oceanMat.uniforms.uMoonDir.value.copy(moonLight.position).normalize();
        }

        function applyWindAndHeight(){
          oceanMat.uniforms.uWind.value = parseFloat(ui.wind.value);
          oceanMat.uniforms.uHeight.value = parseFloat(ui.height.value);
        }

        ui.resetBtn.addEventListener("click", () => {
          ui.wind.value = "12";
          ui.height.value = "1.0";
          ui.light.value = "0.62";
          syncLabels();

          orbit.target.set(0, 1.2, 0);
          orbit.radius = 26;
          orbit.yaw = 1.10;
          orbit.pitch = 0.18;
          updateCamera();

          applyWindAndHeight();
          applyLighting(parseFloat(ui.light.value));
        });

        ui.pauseBtn.addEventListener("click", () => {
          paused = !paused;
          ui.pauseBtn.textContent = paused ? "Resume" : "Pause";
        });

        async function toggleFullscreen(){
          if (!document.fullscreenElement){
            await document.documentElement.requestFullscreen?.();
          }else{
            await document.exitFullscreen?.();
          }
        }
        ui.fsBtn.addEventListener("click", toggleFullscreen);

        ui.wind.addEventListener("input", applyWindAndHeight);
        ui.height.addEventListener("input", applyWindAndHeight);
        ui.light.addEventListener("input", () => applyLighting(parseFloat(ui.light.value)));

        window.addEventListener("keydown", (e) => {
          if (e.code === "Space"){
            e.preventDefault();
            paused = !paused;
            ui.pauseBtn.textContent = paused ? "Resume" : "Pause";
          }
          if (e.key.toLowerCase() === "f"){
            toggleFullscreen();
          }
        });

        // init
        resizeGrain();
        drawGrain();
        applyWindAndHeight();
        applyLighting(parseFloat(ui.light.value));

        // ---------- Loop ----------
        const clock = new THREE.Clock();
        let grainAcc = 0;
        function tick(){
          requestAnimationFrame(tick);
          const dt = clock.getDelta();

          if (!paused){
            oceanMat.uniforms.uTime.value += dt;
            skyMat.uniforms.uTime.value += dt;
          }

          oceanMat.uniforms.uCamPos.value.copy(camera.position);
          oceanMat.uniforms.uRimDir.value.copy(rim.position).normalize();
          oceanMat.uniforms.uMoonDir.value.copy(moonLight.position).normalize();
          skyMat.uniforms.uMoonDir.value.copy(moonLight.position).normalize();

          renderer.render(scene, camera);

          grainAcc += dt;
          if (grainAcc > 0.05){
            drawGrain();
            grainAcc = 0;
          }
        }
        tick();

        // ---------- Resize ----------
        function onResize(){
          renderer.setSize(window.innerWidth, window.innerHeight);
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          resizeGrain();
        }
        window.addEventListener("resize", onResize);

      } catch (e) {
        showError(e);
      }
    })();
  </script>
</body>
</html>
