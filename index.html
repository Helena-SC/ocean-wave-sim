<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Ocean Wave Simulation</title>
  <style>
    :root{
      --panel-bg: rgba(18, 28, 40, 0.58);
      --panel-border: rgba(255,255,255,0.14);
      --text: rgba(235, 245, 255, 0.92);
      --muted: rgba(235, 245, 255, 0.70);
      --shadow: 0 18px 55px rgba(0,0,0,0.35);
      --radius: 18px;
    }
    html, body { height:100%; margin:0; background:#07111d; overflow:hidden; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; }
    #app { position: fixed; inset: 0; }
    canvas { display:block; width:100%; height:100%; }

    /* Cinematic overlays (vignette + soft spotlight) */
    .fx {
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 8;
      background:
        radial-gradient(circle at 62% 38%, rgba(255,255,255,0.16) 0%, rgba(255,255,255,0.06) 18%, rgba(0,0,0,0.00) 42%),
        radial-gradient(circle at 50% 50%, rgba(0,0,0,0.00) 36%, rgba(0,0,0,0.55) 76%, rgba(0,0,0,0.86) 100%);
      mix-blend-mode: multiply;
    }

    /* Grain canvas (subtle film grain) */
    #grain {
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 9;
      opacity: 0.08;
      mix-blend-mode: overlay;
    }

    /* HUD */
    .hud {
      position: fixed;
      left: 18px;
      top: 18px;
      width: min(380px, calc(100vw - 36px));
      padding: 16px 16px 14px;
      border-radius: var(--radius);
      background: var(--panel-bg);
      border: 1px solid var(--panel-border);
      box-shadow: var(--shadow);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      color: var(--text);
      user-select: none;
      z-index: 10;
    }
    .title { display:flex; align-items:center; justify-content:space-between; gap: 10px; margin-bottom: 8px; }
    .title h1 { font-size: 15px; letter-spacing: 0.2px; margin:0; font-weight: 650; }
    .badges { display:flex; gap: 8px; align-items:center; }
    .badge {
      font-size: 11px; color: rgba(235,245,255,0.75);
      padding: 4px 10px; border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.04);
    }
    .badge.live{
      border-color: rgba(120, 255, 200, 0.22);
      background: rgba(120, 255, 200, 0.08);
      color: rgba(200, 255, 235, 0.90);
    }
    .desc {
      font-size: 11px;
      color: rgba(235,245,255,0.70);
      line-height: 1.35;
      margin-bottom: 10px;
    }

    .row { display:flex; gap: 12px; align-items:center; margin: 10px 0; }
    .row label { flex: 0 0 92px; font-size: 12px; color: var(--muted); }
    .row input[type="range"] { flex: 1; accent-color: rgb(120, 210, 255); }
    .val { flex: 0 0 58px; text-align:right; font-variant-numeric: tabular-nums; font-size: 12px; color: var(--text); }

    .buttons { display:flex; gap: 10px; margin-top: 12px; }
    button {
      flex: 1;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06);
      color: var(--text);
      padding: 9px 12px;
      font-size: 12px;
      cursor: pointer;
      transition: transform 120ms ease, background 120ms ease;
    }
    button:hover { background: rgba(255,255,255,0.10); transform: translateY(-1px); }
    button:active { transform: translateY(0px); }

    .hint {
      margin-top: 10px;
      font-size: 11px;
      color: rgba(235,245,255,0.62);
      line-height: 1.35;
    }
    .hint kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 7px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.05);
      color: rgba(235,245,255,0.90);
    }

    /* Error overlay */
    .overlay {
      position: fixed; inset: 0;
      display: none; align-items: center; justify-content: center;
      padding: 22px;
      background: rgba(7, 17, 29, 0.92);
      color: rgba(235, 245, 255, 0.92);
      z-index: 60;
    }
    .overlay .card {
      width: min(860px, 100%);
      border: 1px solid rgba(255,255,255,0.14);
      border-radius: 16px;
      background: rgba(18, 28, 40, 0.55);
      box-shadow: 0 18px 55px rgba(0,0,0,0.35);
      padding: 16px;
    }
    .overlay h2 { margin: 0 0 10px 0; font-size: 14px; }
    .overlay pre {
      margin: 0;
      white-space: pre-wrap;
      word-break: break-word;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 12px;
      color: rgba(235, 245, 255, 0.82);
      line-height: 1.35;
    }
  </style>
</head>

<body>
  <div id="app"></div>
  <div class="fx"></div>
  <canvas id="grain"></canvas>

  <div class="hud" aria-label="Ocean Wave Simulation Controls">
    <div class="title">
      <h1>Ocean Wave Simulation</h1>
      <div class="badges">
        <div class="badge live">Live</div>
      </div>
    </div>

    <div class="desc">
      Procedural ocean surface with real-time lighting. Adjust the elements below for a calmer or stormier sea.
    </div>

    <div class="row">
      <label for="wind">Wind speed</label>
      <input id="wind" type="range" min="0" max="30" step="0.1" value="12" />
      <div class="val" id="windVal">1.20×</div>
    </div>

    <div class="row">
      <label for="height">Wave height</label>
      <input id="height" type="range" min="0" max="3" step="0.01" value="1.0" />
      <div class="val" id="heightVal">1.00×</div>
    </div>

    <div class="row">
      <label for="light">Lighting</label>
      <input id="light" type="range" min="0" max="1" step="0.001" value="0.62" />
      <div class="val" id="lightVal">62%</div>
    </div>

    <div class="buttons">
      <button id="resetBtn" type="button">Reset</button>
      <button id="pauseBtn" type="button">Pause</button>
      <button id="fsBtn" type="button">Fullscreen</button>
    </div>

    <div class="hint">
      Drag to look around. Press <kbd>F</kbd> for fullscreen, <kbd>Space</kbd> to pause.
    </div>
  </div>

  <div class="overlay" id="overlay">
    <div class="card">
      <h2>Ocean Wave Simulation error</h2>
      <pre id="overlayText"></pre>
    </div>
  </div>

  <script type="module">
    const overlay = document.getElementById("overlay");
    const overlayText = document.getElementById("overlayText");
    function showError(err){
      const msg = (err && err.stack) ? err.stack : String(err);
      console.error(msg);
      overlayText.textContent = msg;
      overlay.style.display = "flex";
    }
    function hasWebGL(){
      try{
        const c = document.createElement("canvas");
        return !!(c.getContext("webgl2") || c.getContext("webgl") || c.getContext("experimental-webgl"));
      }catch(_){ return false; }
    }

    async function loadThree(){
      const candidates = [
        "https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.js",
        "https://unpkg.com/three@0.164.1/build/three.module.js",
        "https://esm.sh/three@0.164.1",
      ];
      let lastErr = null;
      for (const url of candidates){
        try { return await import(url); }
        catch (e){ lastErr = e; }
      }
      throw new Error("Failed to load Three.js. Last error: " + (lastErr?.message || lastErr));
    }

    // --- Grain ---
    const grain = document.getElementById("grain");
    const gctx = grain.getContext("2d", { alpha: true });
    function resizeGrain(){
      grain.width = Math.floor(window.innerWidth);
      grain.height = Math.floor(window.innerHeight);
    }
    resizeGrain();

    function drawGrain(){
      const w = grain.width, h = grain.height;
      const img = gctx.createImageData(w, h);
      const d = img.data;
      for (let i = 0; i < d.length; i += 16){
        const v = (Math.random() * 255) | 0;
        d[i+0] = v; d[i+1] = v; d[i+2] = v; d[i+3] = 255;
      }
      gctx.putImageData(img, 0, 0);
    }

    try{
      if (!hasWebGL()) throw new Error("WebGL not available. Enable hardware acceleration.");

      const THREE = await loadThree();

      // ---------- UI ----------
      const ui = {
        wind: document.getElementById("wind"),
        height: document.getElementById("height"),
        light: document.getElementById("light"),
        windVal: document.getElementById("windVal"),
        heightVal: document.getElementById("heightVal"),
        lightVal: document.getElementById("lightVal"),
        resetBtn: document.getElementById("resetBtn"),
        pauseBtn: document.getElementById("pauseBtn"),
        fsBtn: document.getElementById("fsBtn"),
      };

      function syncLabels(){
        ui.windVal.textContent = (Number(ui.wind.value) / 10).toFixed(2) + "×";
        ui.heightVal.textContent = Number(ui.height.value).toFixed(2) + "×";
        ui.lightVal.textContent = Math.round(Number(ui.light.value) * 100) + "%";
      }
      ["input","change"].forEach(evt => {
        ui.wind.addEventListener(evt, syncLabels);
        ui.height.addEventListener(evt, syncLabels);
        ui.light.addEventListener(evt, syncLabels);
      });
      syncLabels();

      // ---------- Renderer ----------
      const app = document.getElementById("app");
      const isMobile = /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
      const dpr = Math.min(window.devicePixelRatio || 1, isMobile ? 1.25 : 2.0);

      const renderer = new THREE.WebGLRenderer({ antialias: !isMobile, powerPreference: "high-performance" });
      renderer.setPixelRatio(dpr);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1.05;
      app.appendChild(renderer.domElement);

      const scene = new THREE.Scene();
      scene.fog = new THREE.FogExp2(0x07111d, 0.0038);

      // ---------- Cinematic camera (low) ----------
      const camera = new THREE.PerspectiveCamera(52, window.innerWidth / window.innerHeight, 0.05, 5000);

      // Minimal orbit
      const orbit = {
        target: new THREE.Vector3(0, 0.7, 0),
        radius: 26,
        yaw: 1.05,
        pitch: 0.16,
        minRadius: 10,
        maxRadius: 120,
        minPitch: 0.05,
        maxPitch: Math.PI * 0.42,
        dragging: false,
        lastX: 0,
        lastY: 0,
        speed: 0.0070
      };
      function updateCamera(){
        const cp = Math.cos(orbit.pitch), sp = Math.sin(orbit.pitch);
        const cy = Math.cos(orbit.yaw),   sy = Math.sin(orbit.yaw);
        const x = orbit.radius * cp * cy;
        const z = orbit.radius * cp * sy;
        const y = orbit.radius * sp;
        camera.position.set(orbit.target.x + x, orbit.target.y + y, orbit.target.z + z);
        camera.lookAt(orbit.target);
      }
      updateCamera();

      renderer.domElement.style.touchAction = "none";
      renderer.domElement.addEventListener("pointerdown", (e) => {
        orbit.dragging = true;
        orbit.lastX = e.clientX; orbit.lastY = e.clientY;
        renderer.domElement.setPointerCapture(e.pointerId);
      });
      renderer.domElement.addEventListener("pointermove", (e) => {
        if (!orbit.dragging) return;
        const dx = e.clientX - orbit.lastX;
        const dy = e.clientY - orbit.lastY;
        orbit.lastX = e.clientX; orbit.lastY = e.clientY;

        orbit.yaw   -= dx * orbit.speed;
        orbit.pitch -= dy * orbit.speed;
        orbit.pitch = Math.max(orbit.minPitch, Math.min(orbit.maxPitch, orbit.pitch));
        updateCamera();
      });
      renderer.domElement.addEventListener("pointerup", (e) => {
        orbit.dragging = false;
        try{ renderer.domElement.releasePointerCapture(e.pointerId); }catch(_){}
      });
      renderer.domElement.addEventListener("wheel", (e) => {
        e.preventDefault();
        const s = (e.deltaY > 0) ? 1.06 : 0.94;
        orbit.radius = Math.max(orbit.minRadius, Math.min(orbit.maxRadius, orbit.radius * s));
        updateCamera();
      }, { passive: false });

      // ---------- Lighting ----------
      const ambient = new THREE.AmbientLight(0xbad7ff, 0.22);
      scene.add(ambient);

      const sun = new THREE.DirectionalLight(0xffffff, 1.35);
      sun.position.set(80, 60, 20);
      scene.add(sun);

      // ---------- Sky: gradient + horizon glow + sun disc ----------
      const skyGeo = new THREE.SphereGeometry(2400, 40, 20);
      const skyMat = new THREE.ShaderMaterial({
        side: THREE.BackSide,
        uniforms: {
          uTime:   { value: 0 },
          uLight:  { value: parseFloat(ui.light.value) },
          uSunDir: { value: new THREE.Vector3().copy(sun.position).normalize() },
          uTop:    { value: new THREE.Color(0x0b2a43) },
          uMid:    { value: new THREE.Color(0x0a2238) },
          uBottom: { value: new THREE.Color(0x07111d) },
        },
        vertexShader: `
          varying vec3 vDir;
          void main(){
            vDir = normalize((modelMatrix * vec4(position,1.0)).xyz);
            gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);
          }
        `,
        fragmentShader: `
          precision highp float;
          varying vec3 vDir;
          uniform float uTime;
          uniform float uLight;
          uniform vec3 uSunDir;
          uniform vec3 uTop, uMid, uBottom;

          float hash(vec2 p){
            p = fract(p * vec2(123.34, 456.21));
            p += dot(p, p + 34.345);
            return fract(p.x * p.y);
          }
          float noise(vec2 p){
            vec2 i = floor(p), f = fract(p);
            float a = hash(i);
            float b = hash(i + vec2(1.0, 0.0));
            float c = hash(i + vec2(0.0, 1.0));
            float d = hash(i + vec2(1.0, 1.0));
            vec2 u = f*f*(3.0-2.0*f);
            return mix(mix(a,b,u.x), mix(c,d,u.x), u.y);
          }
          float fbm(vec2 p){
            float v = 0.0;
            float a = 0.5;
            for(int i=0;i<5;i++){
              v += a * noise(p);
              p *= 2.02;
              a *= 0.5;
            }
            return v;
          }

          void main(){
            vec3 d = normalize(vDir);
            float h = d.y * 0.5 + 0.5;

            // base gradient
            vec3 col = mix(uBottom, uMid, smoothstep(0.00, 0.55, h));
            col = mix(col, uTop, smoothstep(0.32, 1.00, h));

            // horizon glow (key for reflection structure)
            float hz = exp(-abs(d.y) * 10.0);
            vec3 horizonTint = vec3(0.20, 0.33, 0.45);
            col += horizonTint * hz * (0.10 + 0.35*uLight);

            // subtle moving cloudiness
            vec2 p = d.xz / max(0.12, (d.y + 1.2));
            float c = fbm(p * 0.55 + vec2(uTime*0.01, -uTime*0.008));
            col *= 0.92 + 0.08 * c;

            // sun disc + bloom-ish halo
            float sunDot = max(dot(d, normalize(uSunDir)), 0.0);
            float disc = smoothstep(0.9992, 1.0, sunDot); // tiny disc
            float halo = pow(sunDot, 64.0);
            vec3 sunCol = vec3(1.0, 0.93, 0.82);
            col += sunCol * (disc * 1.1 + halo * (0.25 + 0.55*uLight));

            // lift
            col += vec3(0.04,0.05,0.07) * (uLight*0.85);
            gl_FragColor = vec4(clamp(col,0.0,1.0), 1.0);
          }
        `
      });
      const sky = new THREE.Mesh(skyGeo, skyMat);
      scene.add(sky);

      // ---------- Ocean: vertex waves + fragment micro normals + analytic sky reflection ----------
      const oceanSize = 1400;
      const segments = isMobile ? 240 : 420;
      const oceanGeo = new THREE.PlaneGeometry(oceanSize, oceanSize, segments, segments);
      oceanGeo.rotateX(-Math.PI/2);

      const oceanMat = new THREE.ShaderMaterial({
        uniforms: {
          uTime:   { value: 0 },
          uWind:   { value: parseFloat(ui.wind.value) },
          uHeight: { value: parseFloat(ui.height.value) },
          uLight:  { value: parseFloat(ui.light.value) },
          uSunDir: { value: new THREE.Vector3().copy(sun.position).normalize() },
          uCamPos: { value: new THREE.Vector3() },
          uFogColor: { value: new THREE.Color(0x07111d) },
          uFogDensity: { value: 0.0038 },
        },
        vertexShader: `
          precision highp float;
          uniform float uTime;
          uniform float uWind;
          uniform float uHeight;

          varying vec3 vWorldPos;
          varying vec3 vN;

          vec3 gerstner(vec2 xz, vec2 dir, float steep, float amp, float freq, float speed, inout vec3 nAcc){
            float t = uTime * speed;
            float phase = freq * dot(dir, xz) + t;
            float s = sin(phase);
            float c = cos(phase);

            float qa = steep * amp;
            vec3 disp = vec3(dir.x * qa * c, amp * s, dir.y * qa * c);

            nAcc.x += -dir.x * qa * freq * s;
            nAcc.y +=  1.0 - (steep * amp * freq) * c * 0.10;
            nAcc.z += -dir.y * qa * freq * s;

            return disp;
          }

          void main(){
            vec3 pos = position;
            vec2 xz = pos.xz;

            float wind = max(uWind, 0.0);
            float H = uHeight;

            vec2 wdir = normalize(vec2(1.0, 0.35));

            vec2 d1 = normalize(wdir + vec2( 0.18, -0.06));
            vec2 d2 = normalize(wdir + vec2(-0.10,  0.14));
            vec2 d3 = normalize(wdir + vec2( 0.08,  0.22));
            vec2 d4 = normalize(wdir + vec2(-0.22, -0.05));
            vec2 d5 = normalize(wdir + vec2( 0.02, -0.28));

            float w = 0.10 + wind * 0.020;

            vec3 nAcc = vec3(0.0, 1.0, 0.0);
            vec3 disp = vec3(0.0);

            disp += gerstner(xz, d1, 0.62, 0.90*H, 0.040, 1.00*w, nAcc);
            disp += gerstner(xz, d2, 0.52, 0.58*H, 0.070, 1.30*w, nAcc);
            disp += gerstner(xz, d3, 0.40, 0.32*H, 0.120, 1.75*w, nAcc);
            disp += gerstner(xz, d4, 0.30, 0.20*H, 0.190, 2.20*w, nAcc);
            disp += gerstner(xz, d5, 0.22, 0.12*H, 0.300, 2.80*w, nAcc);

            pos += disp;

            // keep geometric normal (micro normal comes in fragment)
            vN = normalize(nAcc);

            vec4 wp = modelMatrix * vec4(pos, 1.0);
            vWorldPos = wp.xyz;

            gl_Position = projectionMatrix * viewMatrix * wp;
          }
        `,
        fragmentShader: `
          precision highp float;

          uniform float uTime;
          uniform float uWind;
          uniform float uHeight;
          uniform float uLight;
          uniform vec3 uSunDir;
          uniform vec3 uCamPos;
          uniform vec3 uFogColor;
          uniform float uFogDensity;

          varying vec3 vWorldPos;
          varying vec3 vN;

          // ---------- noise ----------
          float hash(vec2 p){
            p = fract(p * vec2(123.34, 456.21));
            p += dot(p, p + 34.345);
            return fract(p.x * p.y);
          }
          float noise(vec2 p){
            vec2 i = floor(p), f = fract(p);
            float a = hash(i);
            float b = hash(i + vec2(1.0, 0.0));
            float c = hash(i + vec2(0.0, 1.0));
            float d = hash(i + vec2(1.0, 1.0));
            vec2 u = f*f*(3.0-2.0*f);
            return mix(mix(a,b,u.x), mix(c,d,u.x), u.y);
          }
          float fbm(vec2 p){
            float v = 0.0;
            float a = 0.5;
            for(int i=0;i<6;i++){
              v += a * noise(p);
              p *= 2.03;
              a *= 0.5;
            }
            return v;
          }

          // analytic sky color for reflection (matches sky shader vibes)
          vec3 skyColor(vec3 dir){
            dir = normalize(dir);
            float h = dir.y * 0.5 + 0.5;

            vec3 top    = vec3(0.05, 0.19, 0.28);
            vec3 mid    = vec3(0.04, 0.14, 0.22);
            vec3 bottom = vec3(0.03, 0.07, 0.11);

            vec3 col = mix(bottom, mid, smoothstep(0.00, 0.55, h));
            col = mix(col, top, smoothstep(0.32, 1.00, h));

            float hz = exp(-abs(dir.y) * 10.0);
            col += vec3(0.20,0.33,0.45) * hz * (0.10 + 0.35*uLight);

            float sunDot = max(dot(dir, normalize(uSunDir)), 0.0);
            float disc = smoothstep(0.9992, 1.0, sunDot);
            float halo = pow(sunDot, 64.0);
            vec3 sunCol = vec3(1.0, 0.93, 0.82);
            col += sunCol * (disc * 1.1 + halo * (0.25 + 0.55*uLight));

            return clamp(col, 0.0, 1.0);
          }

          // Fresnel
          float fresnelSchlick(float cosTheta, float F0){
            return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
          }

          // GGX helpers (cheap)
          float D_GGX(float NdotH, float a){
            float a2 = a*a;
            float d = (NdotH*NdotH)*(a2-1.0) + 1.0;
            return a2 / max(3.14159 * d*d, 1e-6);
          }
          float G_Smith(float NdotV, float NdotL, float a){
            float k = (a + 1.0);
            k = (k*k) / 8.0;
            float gv = NdotV / (NdotV*(1.0-k) + k);
            float gl = NdotL / (NdotL*(1.0-k) + k);
            return gv * gl;
          }

          void main(){
            vec3 N = normalize(vN);
            vec3 V = normalize(uCamPos - vWorldPos);
            vec3 L = normalize(uSunDir);

            // ---------- micro normal (the big realism lever) ----------
            // scale + speed with wind
            float wind = max(uWind, 0.0);
            float H = uHeight;

            float scale = mix(0.06, 0.14, clamp(wind/30.0, 0.0, 1.0));   // frequency
            float spd   = 0.025 + 0.010 * (wind/10.0);

            vec2 p = vWorldPos.xz * scale + vec2(uTime*spd, -uTime*spd*0.8);

            // heightfield
            float h0 = fbm(p);
            float eps = 0.22;
            float hx = fbm(p + vec2(eps, 0.0)) - fbm(p - vec2(eps, 0.0));
            float hz = fbm(p + vec2(0.0, eps)) - fbm(p - vec2(0.0, eps));

            // build tangent basis from N
            vec3 up = vec3(0.0, 1.0, 0.0);
            vec3 T = normalize(vec3(1.0,0.0,0.0) - N * dot(N, vec3(1.0,0.0,0.0)));
            vec3 B = normalize(cross(N, T));

            float microStrength = (0.55 + 0.65*(wind/30.0)) * (0.35 + 0.55*H);
            vec3 Nm = normalize(N + (-hx*T - hz*B) * microStrength);

            // slope and foam
            float slope = clamp(1.0 - Nm.y, 0.0, 1.0);
            float foam = smoothstep(0.38, 0.78, slope) * (0.55 + 0.45*H);

            // base water absorption (more depth, darker)
            vec3 deep = vec3(0.02, 0.07, 0.12);
            vec3 shallow = vec3(0.05, 0.16, 0.20);
            float depthHint = clamp((vWorldPos.y + 1.6) * 0.10, 0.0, 1.0);
            vec3 baseCol = mix(deep, shallow, depthHint);

            // reflection from analytic sky
            vec3 R = reflect(-V, Nm);
            vec3 refl = skyColor(R);

            // specular (GGX)
            vec3 Hh = normalize(L + V);
            float NdotL = max(dot(Nm, L), 0.0);
            float NdotV = max(dot(Nm, V), 0.0);
            float NdotH = max(dot(Nm, Hh), 0.0);
            float VdotH = max(dot(V, Hh), 0.0);

            float rough = mix(0.09, 0.045, uLight);
            rough = clamp(rough + slope*0.10, 0.035, 0.22);

            float D = D_GGX(NdotH, rough);
            float G = G_Smith(NdotV, NdotL, rough);
            float F = fresnelSchlick(VdotH, 0.02);

            float spec = (D * G * F) / max(4.0 * NdotV * NdotL, 1e-4);

            // sun glitter amplification (keeps it cinematic)
            float glitter = pow(max(dot(R, L), 0.0), 120.0) * (0.25 + 0.55*(wind/30.0));
            vec3 sunCol = vec3(1.0, 0.96, 0.90);

            // combine: reflection dominates at grazing angles (Fresnel)
            float Fv = fresnelSchlick(NdotV, 0.02);
            vec3 col = mix(baseCol, refl, clamp(Fv * (0.65 + 0.20*uLight), 0.0, 1.0));

            // add spec
            col += sunCol * spec * NdotL * (0.9 + 0.9*uLight);
            col += sunCol * glitter * (0.12 + 0.30*uLight);

            // foam
            col = mix(col, vec3(0.86, 0.93, 1.00), foam * 0.20);

            // subtle subsurface lift near sun direction
            float wrap = clamp((dot(Nm, L) + 0.35) / 1.35, 0.0, 1.0);
            col += vec3(0.02, 0.06, 0.08) * wrap * (0.10 + 0.18*uLight);

            // horizon blending (removes “flat band” feeling)
            float horizon = pow(1.0 - max(dot(V, vec3(0.0,1.0,0.0)), 0.0), 2.0);
            col = mix(col, skyColor(normalize(vec3(V.x, 0.15, V.z))), horizon * 0.06);

            // cinematic contrast
            col = pow(col, vec3(0.92));

            // fog
            float dist = length(uCamPos - vWorldPos);
            float fog = 1.0 - exp(-uFogDensity * uFogDensity * dist * dist);
            col = mix(col, uFogColor, clamp(fog, 0.0, 1.0));

            gl_FragColor = vec4(col, 1.0);
          }
        `
      });

      const ocean = new THREE.Mesh(oceanGeo, oceanMat);
      ocean.position.y = 0.0;
      scene.add(ocean);

      // ---------- Interaction ----------
      let paused = false;

      function applyLighting(l){
        const t = THREE.MathUtils.clamp(l, 0, 1);

        // sun
        const elev = THREE.MathUtils.lerp(0.12, 0.82, t);
        const azim = 0.38;
        const r = 140.0;
        const x = Math.cos(azim) * r;
        const z = Math.sin(azim) * r;
        const y = THREE.MathUtils.lerp(12, 88, elev);

        sun.position.set(x, y, z);
        sun.intensity = THREE.MathUtils.lerp(0.80, 1.55, t);
        ambient.intensity = THREE.MathUtils.lerp(0.16, 0.30, t);

        // sky tones
        const top = new THREE.Color().setHSL(0.58, 0.52, THREE.MathUtils.lerp(0.17, 0.34, t));
        const mid = new THREE.Color().setHSL(0.56, 0.48, THREE.MathUtils.lerp(0.10, 0.27, t));
        const bottom = new THREE.Color().setHSL(0.60, 0.66, THREE.MathUtils.lerp(0.05, 0.10, t));

        skyMat.uniforms.uTop.value.copy(top);
        skyMat.uniforms.uMid.value.copy(mid);
        skyMat.uniforms.uBottom.value.copy(bottom);

        skyMat.uniforms.uLight.value = t;
        skyMat.uniforms.uSunDir.value.copy(sun.position).normalize();

        oceanMat.uniforms.uLight.value = t;
        oceanMat.uniforms.uSunDir.value.copy(sun.position).normalize();

        renderer.toneMappingExposure = THREE.MathUtils.lerp(0.98, 1.10, t);
      }

      function applyWindAndHeight(){
        oceanMat.uniforms.uWind.value = parseFloat(ui.wind.value);
        oceanMat.uniforms.uHeight.value = parseFloat(ui.height.value);
      }

      ui.resetBtn.addEventListener("click", () => {
        ui.wind.value = "12";
        ui.height.value = "1.0";
        ui.light.value = "0.62";
        syncLabels();
        applyWindAndHeight();
        applyLighting(parseFloat(ui.light.value));

        orbit.target.set(0, 0.7, 0);
        orbit.radius = 26;
        orbit.yaw = 1.05;
        orbit.pitch = 0.16;
        updateCamera();
      });

      ui.pauseBtn.addEventListener("click", () => {
        paused = !paused;
        ui.pauseBtn.textContent = paused ? "Resume" : "Pause";
      });

      async function toggleFullscreen(){
        if (!document.fullscreenElement){
          await document.documentElement.requestFullscreen?.();
        }else{
          await document.exitFullscreen?.();
        }
      }
      ui.fsBtn.addEventListener("click", toggleFullscreen);

      ui.wind.addEventListener("input", applyWindAndHeight);
      ui.height.addEventListener("input", applyWindAndHeight);
      ui.light.addEventListener("input", () => applyLighting(parseFloat(ui.light.value)));

      window.addEventListener("keydown", (e) => {
        if (e.code === "Space"){
          e.preventDefault();
          paused = !paused;
          ui.pauseBtn.textContent = paused ? "Resume" : "Pause";
        }
        if (e.key.toLowerCase() === "f"){
          toggleFullscreen();
        }
      });

      // init
      applyWindAndHeight();
      applyLighting(parseFloat(ui.light.value));

      // ---------- Loop ----------
      const clock = new THREE.Clock();
      let grainAcc = 0;

      function tick(){
        requestAnimationFrame(tick);

        const dt = clock.getDelta();
        if (!paused){
          oceanMat.uniforms.uTime.value += dt;
          skyMat.uniforms.uTime.value += dt;
        }

        // keep ocean under camera to avoid visible plane edge seam
        // snap to reduce floating jitter
        const snap = 2.0;
        ocean.position.x = Math.round(camera.position.x / snap) * snap;
        ocean.position.z = Math.round(camera.position.z / snap) * snap;

        oceanMat.uniforms.uCamPos.value.copy(camera.position);

        renderer.render(scene, camera);

        // update grain at ~20fps
        grainAcc += dt;
        if (grainAcc > 0.05){
          drawGrain();
          grainAcc = 0;
        }
      }
      tick();

      // ---------- Resize ----------
      function onResize(){
        renderer.setSize(window.innerWidth, window.innerHeight);
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        resizeGrain();
      }
      window.addEventListener("resize", onResize);

    } catch (e) {
      showError(e);
    }
  </script>
</body>
</html>
